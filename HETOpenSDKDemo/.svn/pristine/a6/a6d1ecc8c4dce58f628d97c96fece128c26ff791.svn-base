//
//  CLWIFIOpenSDKProtocol.m
//  HETPublicSDK_DeviceCore
//
//  Created by mr.cao on 16/2/20.
//  Copyright © 2016年 HET. All rights reserved.
//

#import "HETWIFIOpenSDKProtocol.h"
//#import "HETUserDefaultsPreference.h"
#import <sys/socket.h>
#import <sys/sysctl.h>
#import <net/if.h>
#import <net/if_dl.h>
#import <ifaddrs.h>
//#import <NSString+SAMAdditions.h>
#import <arpa/inet.h>
/**
 * 开放平台协议格式
 * -------------------------------------------------------------------------------------------------------------------------
 * | 0x5A | Length | Protocol Version | Protocol Type  | Device Type | Mac Addr |     SN | Reserved | Command Type | Frame Body | FCS  |
 * |-------------------------------------------------------------------------------------------------------------------------|
 * | 1byte| 2byte  |     1byte        |      1byte     |   8byte  |     6byte   |    4byte |8byte   |
 2byte        |     Nbyte | 2byte|
 * -------------------------------------------------------------------------------------------------------------------------
 * <p/>
 * 0x5A: 帧开始标志;
 * Length:从数据长度到数据校验的字节数;
 * Protocol Version:协议版本，详情见版本表(注 1);0x40
 * Protocol Type:协议类型 0x00 ID 认证 0x01 业务 数据 0x02 WIFI 升级 0x03 PCB 升级 0xFF 生产测试;
 * Device Type:整机品牌【4】+ 设 备分类【2】+ 设备 子分类【1】+ 产品 序号【1】
 * Mac Addr:客户端 WIFI 模组的 MAC 地址 ACCF233BA86A;
 * SN:数据帧序列号
 * Reserved:保留位;
 * Command Type:相关操作命令字,高字节为数据方向; Bit7~Bit7  数据源：10-服务器 01-手机 00-终端
 * Frame Body:帧数据段字节数，合法值范围：0～1024(注)，汉枫模块不超过 200 字节;
 * FCS:帧数据段内容 CRC16 校验值(CRC-16/X25 X16+X12+X5+1),包含所有帧数据除外不包含0x5a;
 */
//5a 0022 40  00 0000afc8 0001 03 01 74daea 812380   00 00000300 00000000 00000004 0004d4
//5a 0032 40  01 0000afc8 0007 0601 8c8b83 a10a2e   00 00004700 00000000 00000001 0e000000 00000004 00000000 00000000 00c09f
//5a 0022 40  00 0000afc8 0100 03 01  74daea812380   0000005f 0000000000000000 0400 6b5a>,协议类型:40,扫描的设备大分类:0，小分类:1,命令类型:0400

//5a 0046 40  00 0000afc8 0001 03 00  74daea812380   00000000 0000000000000000 0200 313663 38633732 61356163 37633537 62333531 64366631 66386666 3663616164  3d  8d9e be23 29        23e1

//5a 0048 40  00 00000000 0000 00 00  000000000000   00000016 0000000000000000 0200 41453746 35433833 32323339 37363832 32343737 44413431 44463142      41313832  3d8d9ebe 2329 33f9

/*<5a004640 000000af c8000103 0074daea 81238000 00000000 00000000 00000002 00313663 38633732 61356163 37633537 62333531 64366631 66386666 36636161 643d8d9e be232923 e1>
 
 
 Printing description of obj->_body:
 <31366338 63373261 35616337 63353762 33353164 36663166 38666636 63616164 3d8d9ebe 2329>*/

@implementation HETWIFIOpenSDKProtocol


+(HETWIFICommonReform*)transformData:(NSData *)data
{
    HETWIFICommonReform *obj = [[HETWIFICommonReform alloc] init];
    
    const char* bytes = [data bytes];
    int length = (int)data.length;
    char start = *bytes;
    unsigned short cmd = 0;
    unsigned short length1 =*(unsigned short *)(bytes + 1);
    HTONS(length1);
    //NSLog(@"length:%d,%d,%d",length,length1,HTONS(length1));
    unsigned long long macaddr=0;
    //报文头不对
    if (start != (char)0x5a) {
        return nil;
    }
    //长度不等
    if (length1 != length-1) {
        return nil;
    }
    unsigned short temp1 = [self crc16with:bytes+1 andlength:length-3];
    unsigned short crc = NTOHS(*(unsigned short *)(bytes +length -2));
    //CRC校验失败
    if (crc != temp1) {
        return nil;
    }
    
    unsigned long long temp;
    memcpy((char *)&temp, bytes+13, 8);
    macaddr = (((unsigned long long )ntohl((unsigned int)((temp << 32) >> 32))) << 32) | (unsigned int)ntohl((int)(temp >> 32));//字节序转换等同于NTOHLL(temp);
    macaddr = macaddr>>16;
    NSString *mac = [[NSString stringWithFormat:@"%llx",macaddr] uppercaseString];
    char Pro_version = *(bytes+3);
    char Pro_type = *(bytes +4);
    cmd = (*(bytes +31))*256 + *(bytes +32);
    unsigned long device_brand=ntohl(*(unsigned long *)(bytes +5));
    //unsigned long deviceNum =NTOHS(*(unsigned long *)(bytes + 3));
    unsigned short Dev_type = NTOHS(*(unsigned short *)(bytes +9));
    
    unsigned long packetNum=ntohl(*(unsigned long *)(bytes +19));
    NSData *content = [NSData dataWithBytes:bytes+32 length:length1-34];
    
    
    obj.startflag=start;
    obj.protocol_version=Pro_version;
    obj.protocol_type=Pro_type;
    //obj.device_type=((Dev_type&0xff00)>>8);
    //obj.device_subtype=(Dev_type&0x00ff);
    obj.device_type=Dev_type;
    obj.device_subtype=*(bytes +11);
    obj.device_mac=mac;
    obj.device_cmdtype=cmd;
    obj.body=content;
    obj.body_length=content.length;
    obj.device_brand=device_brand;
    obj.packetNum=packetNum;

    return obj;
    
    
}
+(NSData *)fetchBindPacketWithObj:(HETWIFICommonReform *)obj  withUserKey:(NSString *)userKey{
    unsigned char ipArray[1];
    for(int i = 0;i<1;i++){
        //NSDictionary *dic = deviceInfo;
        NSString *iptr=obj.device_ip;//[dic objectForKey:@"ip"];
        unsigned char lastIpNum = [[[iptr componentsSeparatedByString:@"."] lastObject] integerValue];
        ipArray[i] = lastIpNum;
    }
    
    
    /*NSDictionary *serverDic = [[NSUserDefaults standardUserDefaults] objectForKey:@"HETServerConfig"];
     // NSString *md5 = [[NSUserDefaults standardUserDefaults] objectForKey:@"accountAndPassMd5Str"];
     if ([HETUserInfo userInfo].userId == nil) {
     return nil ;
     }
     
     NSString *md5 = [[HETUserInfo userInfo].userId sam_MD5Digest];
     unsigned int ip = inet_addr([[serverDic objectForKey:@"serverIp"] UTF8String]);
     unsigned short port = [[serverDic objectForKey:@"serverPort"] shortValue];
     
     char content[38+1];
     memset(content, 0, 38+1);
     *(unsigned int *)(content) = ip;
     *(unsigned short *)(content +4) = htons(port);
     memcpy(content + 6, [md5 UTF8String], 32);
     memcpy(content + 38, ipArray, 1);*/
    /*NSMutableDictionary *packetdic = [[NSMutableDictionary alloc] init];
     [packetdic setObject:[NSData dataWithBytes:content length:38+1] forKey:@"data"];
     [packetdic setObject:@(0x4010) forKey:@"cmd"];
     [packetdic setObject:@(0x41) forKey:@"proversion"];
     [packetdic setObject:@(0x02) forKey:@"protype"];
     [packetdic setObject:@(0) forKey:@"devtype"];
     [packetdic setObject:@"000000000000" forKey:@"mac"];*/
    /*obj.body=[NSData dataWithBytes:content length:38+1];
     obj.device_cmdtype=0x4010;
     //obj.protocol_version=0x41;
     obj.protocol_type=0x02;
     obj.device_type=0;
     obj.device_mac=@"000000000000";
     
     NSData *contentData = obj.body;//[dic objectForKey:@"data"];
     char Pro_ver =obj.protocol_version;// [[dic objectForKey:@"proversion"] charValue];
     char Pro_type =obj.protocol_type ;//[[dic objectForKey:@"protype"] charValue];
     unsigned short temp1 = obj.device_cmdtype;//[[dic objectForKey:@"cmd"] shortValue];
     unsigned short cmd = HTONS(temp1);
     unsigned short temp2 = (obj.device_subtype&0x00ff)|((obj.device_type<<8)&0xff00);// obj.device_subtype;//[[dic objectForKey:@"devtype"] shortValue];
     unsigned short Dev_type = HTONS(temp2);
     NSString *macaddrstr = obj.device_mac;//[dic objectForKey:@"mac"];
     
     unsigned long long temp;
     NSScanner *scanner = [NSScanner scannerWithString:macaddrstr];
     (void) [scanner scanHexLongLong:&temp];
     unsigned long long macaddr;
     macaddr = (((unsigned long long )htonl((unsigned int)((temp << 32) >> 32))) << 32) | (unsigned int)htonl((int)(temp >> 32));
     macaddr = macaddr>>16;
     
     unsigned short temp3 = [contentData length];
     char retdata[18+temp3];
     unsigned short contentLength = temp3;
     HTONS(contentLength);
     retdata[0] = 0xf2;
     retdata[1] = Pro_ver;
     retdata[2] = Pro_type;
     memcpy(retdata+3, (char *)(&cmd), 2);
     memcpy(retdata+5, (char *)(& macaddr), 6);
     memcpy(retdata+11, (char *)(&Dev_type), 2);
     retdata[13] = 0;
     memcpy(retdata+14, (char *)(&contentLength), 2);
     memcpy(retdata+16, [contentData bytes], [contentData length]);
     unsigned short temp4 = [self crc16with:retdata+1 andlength:15+temp3];
     unsigned short crc = HTONS(temp4);
     memcpy(retdata+temp3+16, (char *)(& crc), 2);
     return [NSData dataWithBytes:retdata length:18+temp3];*/
    
    NSDictionary *serverDic = [[NSUserDefaults standardUserDefaults] objectForKey:@"HETServerConfig"];
    // NSString *md5 = [[NSUserDefaults standardUserDefaults] objectForKey:@"accountAndPassMd5Str"];
    if (!userKey) {
        return nil ;
    }
    
    NSString *md5 = userKey;
    //NSString *md5 =@"0";// [HETUserDefaultsPreference sharedInstance].accountAndPassMd5Str;
    unsigned int ip = inet_addr([[serverDic objectForKey:@"serverIp"] UTF8String]);
    unsigned short port = [[serverDic objectForKey:@"serverPort"] shortValue];
    
    char content[38];
    memset(content, 0, 38);
    *(unsigned int *)(content+32) = ip;
    *(unsigned short *)(content +36) = htons(port);
    memcpy(content, [md5 UTF8String], 32);
    obj.body=[NSData dataWithBytes:content length:38];
    obj.device_cmdtype=0x0200;
    
    NSData *contentData = obj.body;
    char Pro_ver =obj.protocol_version;
    char Pro_type =obj.protocol_type;
    unsigned short temp1 = obj.device_cmdtype;
    unsigned short cmd = HTONS(temp1);
    unsigned short temp2 =obj.device_type;// (obj.device_subtype&0x00ff)|((obj.device_type<<8)&0xff00);
    unsigned short Dev_type = HTONS(temp2);
    unsigned long temp4 = obj.device_brand;
    unsigned long  device_brand=htonl(temp4);
    char device_subType=obj.device_subtype;
    NSString *macaddrstr = obj.device_mac;
    
    unsigned long sn=htonl(obj.packetNum);
    
    unsigned long long temp;
    NSScanner *scanner = [NSScanner scannerWithString:macaddrstr];
    (void) [scanner scanHexLongLong:&temp];
    unsigned long long macaddr;
    macaddr = (((unsigned long long )htonl((unsigned int)((temp << 32) >> 32))) << 32) | (unsigned int)htonl((int)(temp >> 32));
    macaddr = macaddr>>16;
    
    unsigned short temp3 = [contentData length];
    char retdata[35+temp3];
    memset(retdata, 0, 35+temp3);
    unsigned short contentLength = temp3;
    HTONS(contentLength);
    retdata[0] = 0x5a;
    retdata[1]=((34+temp3)&0xff00)<<8;
    retdata[2]=((34+temp3)&0x00ff);
    
    retdata[3] = Pro_ver;
    retdata[4] = Pro_type;
    memcpy(retdata+5, (char *)(& device_brand), 4);
    memcpy(retdata+9, (char *)(&Dev_type), 2);
    memcpy(retdata+11, (char *)(&device_subType), 1);
    memcpy(retdata+13, (char *)(& macaddr), 6);
    
    memcpy(retdata+19, (char *)(& sn), 4);
    memcpy(retdata+31, (char *)(&cmd), 2);
    
    memcpy(retdata+33, [contentData bytes], [contentData length]);
    unsigned short crctemp = [self crc16with:retdata+1 andlength:32+temp3];
    unsigned short crc = HTONS(crctemp);
    memcpy(retdata+temp3+33, (char *)(& crc), 2);
    return [NSData dataWithBytes:retdata length:35+temp3];
    
}
+(NSData *)fetchLittleLoopPacketWithObj:(HETWIFICommonReform *)obj
{
    NSData *contentData = obj.body;
    char Pro_ver =obj.protocol_version;
    char Pro_type =obj.protocol_type;
    unsigned short temp1 = obj.device_cmdtype;
    unsigned short cmd = HTONS(temp1);
    unsigned short temp2 = obj.device_subtype;//(obj.device_subtype&0x00ff)|((obj.device_type<<8)&0xff00);
    unsigned short Dev_type = HTONS(temp2);
    unsigned long temp4 = obj.device_brand;
    unsigned long  device_brand=htonl(temp4);
    char device_subType=obj.device_subtype;
    NSString *macaddrstr = obj.device_mac;
    unsigned long sn=htonl(obj.packetNum);
    
    unsigned long long temp;
    NSScanner *scanner = [NSScanner scannerWithString:macaddrstr];
    (void) [scanner scanHexLongLong:&temp];
    unsigned long long macaddr;
    macaddr = (((unsigned long long )htonl((unsigned int)((temp << 32) >> 32))) << 32) | (unsigned int)htonl((int)(temp >> 32));
    macaddr = macaddr>>16;
    
    unsigned short temp3 = [contentData length];
    char retdata[35+temp3];
    memset(retdata, 0, 35+temp3);
    unsigned short contentLength = temp3;
    HTONS(contentLength);
    retdata[0] = 0x5a;
    retdata[1]=((34+temp3)&0xff00)<<8;
    retdata[2]=((34+temp3)&0x00ff);
    retdata[3] = Pro_ver;
    retdata[4] = Pro_type;
    memcpy(retdata+5, (char *)(& device_brand), 4);
    memcpy(retdata+9, (char *)(&Dev_type), 2);
    memcpy(retdata+11, (char *)(&device_subType), 1);
    memcpy(retdata+13, (char *)(& macaddr), 6);
    memcpy(retdata+19, (char *)(& sn), 4);
    memcpy(retdata+31, (char *)(&cmd), 2);
    
    memcpy(retdata+33, [contentData bytes], [contentData length]);
    unsigned short crctemp = [self crc16with:retdata+1 andlength:32+temp3];
    unsigned short crc = HTONS(crctemp);
    memcpy(retdata+temp3+33, (char *)(& crc), 2);
    return [NSData dataWithBytes:retdata length:35+temp3];
}
//CRC校验
+(unsigned short)crc16with:(const char *)data andlength:(int) length
{
    char j;
    int i;
    unsigned short retCrc16;
    retCrc16 = 0xffff;
    for(i=0;i<length;i++)
    {
        retCrc16 ^=((*data++)&0x000000ff);
        for(j = 0;j<8;j++){
            if(retCrc16&0x01)
            {
                retCrc16=(retCrc16>>1)^0x8408;
            }
            else{
                retCrc16>>=0x01;
            }
        }
    }
    return ~retCrc16;
}


@end
