//
//  Ble_Protocol_Tool.m
//  SmartHome
//
//  Created by Sandy wu on 14-8-7.
//  Copyright (c) 2014年 Het. All rights reserved.
//

#import "HETBLEProtocol.h"
#import "BLEHeader.h"
@implementation HETBLEReform
{
    NSString *_DeviceVersion;
}
@end
@implementation HETBLEProtocol

uint8_t ble_currentTimeOffset(){
    time_t t = time(NULL);
    struct tm lt = {0};
    localtime_r(&t, &lt);
    uint8_t offset=lt.tm_gmtoff/3600+12;
    return offset;
}

void ble_gmtTimeString(uint8_t* timeValue){

    time_t rawtime;
    struct tm * timeinfo;

    time ( &rawtime );
    timeinfo = gmtime ( &rawtime );
	char buffer[80]={0};
	strftime(buffer, 80, "%Y%m%d%H%M%S", timeinfo);

    //    uint8_t timeValue[20]={0};
    //年份前两位
    int yearSice1900=timeinfo->tm_year;

    uint16_t yearValue=yearSice1900+1900;
    yearValue=ntohs(yearValue);
    memcpy(timeValue, &yearValue, 2);

    uint8_t monthValue=timeinfo->tm_mon+1;
    memcpy(timeValue+2, &monthValue, 1);

    uint8_t dayValue=timeinfo->tm_mday;
    memcpy(timeValue+3, &dayValue, 1);

    uint8_t hourValue=timeinfo->tm_hour;
    memcpy(timeValue+4, &hourValue, 1);

    uint8_t minuteValue=timeinfo->tm_min;
    memcpy(timeValue+5, &minuteValue, 1);

    uint8_t secondValue=timeinfo->tm_sec;
    memcpy(timeValue+6, &secondValue, 1);
}

void Init_Ble_Protocol_Head(uint8_t *packetArray,short comdNo,uint16_t dataLength,uint8_t* uniqueID,NSString *deviceVersion)
{
    //起始标志 0xF2
    memset(packetArray,BLE_PROTOCOL_START_FLAG,1);

    if (comdNo == REQUEST_CONFIRM_UPGRADE_COMMAND) {
        // 发送确认升级指令时,需要将新版本号告诉设备端
        NSString *versionStr = [[NSUserDefaults standardUserDefaults] valueForKey:@"MattressUpgradeVersion"];
        if (versionStr.length > 0||deviceVersion.length>0) {
            NSArray *ver = [versionStr componentsSeparatedByString:@"."];
            uint16_t version = ([[ver firstObject] intValue]<<10)|([[ver objectAtIndex:1] intValue]<<5)|([[ver lastObject] intValue]);
//            memcpy(packetArray+1, &version, sizeof(uint16_t));
            packetArray[1] = version/256;
            packetArray[2] = version%256;
            memset(packetArray+3, 0, 3);
            //命令字0x0021
            uint16_t comdNoVale=ntohs(comdNo);
            //    uint16_t comdNoVale=comdNo;
            memcpy(packetArray+6, &comdNoVale, sizeof(uint16_t));
        }
        else {
            memset(packetArray+1,0,5);
            //命令字0x0021
            uint16_t comdNoVale=ntohs(comdNo);
            //    uint16_t comdNoVale=comdNo;
            memcpy(packetArray+6, &comdNoVale, sizeof(uint16_t));

        }
    }
    else {
        memset(packetArray+1,0,5);
        //命令字0x0021
        uint16_t comdNoVale=ntohs(comdNo);
        //    uint16_t comdNoVale=comdNo;
        memcpy(packetArray+6, &comdNoVale, sizeof(uint16_t));
    }

//    memset(packetArray+1,0,5);
//    //命令字0x0021
//    uint16_t comdNoVale=ntohs(comdNo);
//    //    uint16_t comdNoVale=comdNo;
//    memcpy(packetArray+6, &comdNoVale, sizeof(uint16_t));

    //唯一ID
    memcpy(packetArray+8, uniqueID, 6);
//    memset(packetArray+8, 0, 6);

    //    int timeZoneOffset=[NSDate currentTimeZoneOffset];
    //时区 用时区偏移加上12
    uint8_t timeOffset=ble_currentTimeOffset();
    memset(packetArray+14, timeOffset, 1);

    uint8_t timeValue[7]={0};
    ble_gmtTimeString(timeValue);

    //协议时间置
    memcpy(packetArray+15, timeValue, 7);
    //数据长度
    uint16_t dataLengthValue=ntohs(dataLength);
    memcpy(packetArray+22, &dataLength, sizeof(dataLengthValue));
    //memchr(packetArray+22, dataLength, sizeof(dataLengthValue));
    //    uint16_t dataLengthValue=dataLength;
//    if (dataLength>0) {
//        memcpy(packetArray+22, &dataLengthValue, sizeof(uint16_t));
//        memcpy(packetArray+22+sizeof(dataLength), protocolData, dataLength);
//        memset(packetArray+22+sizeof(dataLength)+dataLength, BLE_PROTOCOL_END_FLAG, 1);
//    }
//    else{
//        memset(packetArray+22+sizeof(dataLength)+dataLength, BLE_PROTOCOL_END_FLAG, 1);
//    }
}

//获取统计数据的数据包
+(HETBLEProtocol*)getRequestStatisticalPacketData:(NSString*)uinqueIDString{
    uint8_t packetHead[sizeof(Ble_Protocol_Head_T)]={0};
//    uint8_t uinqueID[6]={0};
    uint8_t* uinqueID=(uint8_t*)[uinqueIDString UTF8String];

    Init_Ble_Protocol_Head(packetHead, REQUEST_GET_DATA_COMMAND, 0,uinqueID,nil);

    NSMutableData* packetData=[[NSMutableData alloc] initWithCapacity:0];
    NSData* packetHeadData=[NSData dataWithBytes:packetHead length:sizeof(Ble_Protocol_Head_T)];
    [packetData appendData:packetHeadData];

    uint8_t endCommand=BLE_PROTOCOL_END_FLAG;
    [packetData appendBytes:&endCommand length:1];

    HETBLEProtocol* obj= [[self alloc] init];
    uint8_t byte[]={0};

//    obj.singleAppResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.singleDeviceResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.packetData = packetData;
    return obj;

//    return packetData;
}


//通知设备清除统计数据的数据包
+(HETBLEProtocol*)getDeleteStatisticalPacketData:(NSString*)uinqueIDString{
    uint8_t packetHead[sizeof(Ble_Protocol_Head_T)]={0};
    uint8_t* uinqueID=(uint8_t*)[uinqueIDString UTF8String];
    Init_Ble_Protocol_Head(packetHead, REQUEST_DELETE_DATA_COMMAND, 0,uinqueID,nil);

    NSMutableData* packetData=[[NSMutableData alloc] initWithCapacity:0];
    NSData* packetHeadData=[NSData dataWithBytes:packetHead length:sizeof(Ble_Protocol_Head_T)];
    [packetData appendData:packetHeadData];

    uint8_t endCommand=BLE_PROTOCOL_END_FLAG;
    [packetData appendBytes:&endCommand length:1];
    HETBLEProtocol* obj= [[self alloc] init];
    uint8_t byte[]={0};
    obj.singleDeviceResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.singleAppResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.packetData = packetData;
    return obj;

}


/**
 *  获取实时数据数据包
 *
 *  @param uinqueIDString 唯一ID
 *
 *  @return 返回获取实时数据的数据包
 */
+(HETBLEProtocol*)getRequestRealTimePacketData:(NSString*)uinqueIDString{
    uint8_t packetHead[sizeof(Ble_Protocol_Head_T)]={0};
    uint8_t* uinqueID=(uint8_t*)[uinqueIDString UTF8String];
    Init_Ble_Protocol_Head(packetHead, REQUEST_REALTIME_DATA_COMMAND, 0,uinqueID,nil);

    NSMutableData* packetData=[[NSMutableData alloc] initWithCapacity:0];
    NSData* packetHeadData=[NSData dataWithBytes:packetHead length:sizeof(Ble_Protocol_Head_T)];
    [packetData appendData:packetHeadData];

    uint8_t endCommand=BLE_PROTOCOL_END_FLAG;
    [packetData appendBytes:&endCommand length:1];

   HETBLEProtocol* obj= [[self alloc] init];
    uint8_t byte[]={0};
    obj.singleDeviceResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.singleAppResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.packetData = packetData;
    return obj;
}


void ble_gmtTimeString_new(uint8_t* timeValue){

    time_t rawtime;
    struct tm * timeinfo;

    time ( &rawtime );
    timeinfo = gmtime ( &rawtime );
    char buffer[80]={0};
    strftime(buffer, 80, "%Y%m%d%H%M%S", timeinfo);

    //    uint8_t timeValue[20]={0};
    //年份前两位
//    int yearSice1900=timeinfo->tm_year;
    int yearSice2010=timeinfo->tm_year+(1900-2010);
    // 时间以2010年为基数+
    uint8_t yearValue=yearSice2010;
//    yearValue=ntohs(yearValue);
    memcpy(timeValue, &yearValue, 1);

    uint8_t monthValue=timeinfo->tm_mon+1;
    memcpy(timeValue+1, &monthValue, 1);

    uint8_t dayValue=timeinfo->tm_mday;
    memcpy(timeValue+2, &dayValue, 1);

    uint8_t hourValue=timeinfo->tm_hour;
    memcpy(timeValue+3, &hourValue, 1);

    uint8_t minuteValue=timeinfo->tm_min;
    memcpy(timeValue+4, &minuteValue, 1);

    uint8_t secondValue=timeinfo->tm_sec;
    memcpy(timeValue+5, &secondValue, 1);
}

void Init_Ble_Protocol_Head_New(uint8_t *packetArray,short comdNo,uint16_t dataLength,uint8_t* uniqueID)
{
    // 起始标志 0xF2
    memset(packetArray, BLE_PROTOCOL_START_FLAG, 1);
    // 协议类型
    memset(packetArray+1, 0x00, 1);
    // 协议版本
    memset(packetArray+2, 0x41, 1);
    // 保留字
    memset(packetArray+3, 0x00, 1);
    //协议时间
    uint8_t timeValue[6]={0};
    ble_gmtTimeString_new(timeValue);
    memcpy(packetArray+4, timeValue, 6);
    //时区 用时区偏移加上12
    uint8_t timeOffset=ble_currentTimeOffset();
    memset(packetArray+10, timeOffset, 1);
    //命令字
    uint16_t comdNoVale=ntohs(comdNo);
    memcpy(packetArray+11, &comdNoVale, sizeof(uint16_t));
    //数据长度
    uint16_t dataLengthValue=ntohs(dataLength);
    //memchr(packetArray+13, dataLength, sizeof(dataLengthValue)); bug
    memcpy(packetArray+15, &dataLength, sizeof(dataLengthValue));
}

/**
 *  根据旧的蓝牙协议生成数据包
 *
 *  @param cmdNo          命令字
 *  @param uinqueIDString 唯一ID
 *
 *  @return 返回对应的包
 */
+ (NSData *)createBlePacketWithCmdno:(uint16_t)cmdNo withUinqueId:(NSString *)uinqueIDString{
    uint8_t packetHead[sizeof(Ble_Protocol_Head_T)] = {0};
    uint8_t *uniqueID = (uint8_t*)[uinqueIDString UTF8String];
    Init_Ble_Protocol_Head(packetHead, cmdNo, 0,uniqueID,nil);
    NSMutableData* packetData=[[NSMutableData alloc] initWithCapacity:0];
    NSData* packetHeadData=[NSData dataWithBytes:packetHead length:sizeof(Ble_Protocol_Head_T)];
    [packetData appendData:packetHeadData];

    uint8_t endCommand=BLE_PROTOCOL_END_FLAG;
    [packetData appendBytes:&endCommand length:1];
    return packetData;
}

/**
 *  获取确认蓝牙升级的数据包
 *
 *  @param uinqueIDString 唯一ID
 *
 *  @return 返回获取蓝牙升级的数据包
 */
+(HETBLEProtocol *)getRequestConfirmUpgrade:(NSString *)uinqueIDString {
//    NSData *packetData = [self createBlePacketWithCmdno:REQUEST_CONFIRM_UPGRADE_COMMAND withUinqueId:uinqueIDString];
//    if (packetData && packetData.length > 0) {
//        return packetData;
//    }
//    return nil;
    
    
    
    uint8_t packetHead[sizeof(Ble_Protocol_Head_T)]={0};
    uint8_t* uinqueID=(uint8_t*)[uinqueIDString UTF8String];
    Init_Ble_Protocol_Head(packetHead, REQUEST_CONFIRM_UPGRADE_COMMAND, 0,uinqueID,nil);
    
    NSMutableData* packetData=[[NSMutableData alloc] initWithCapacity:0];
    NSData* packetHeadData=[NSData dataWithBytes:packetHead length:sizeof(Ble_Protocol_Head_T)];
    [packetData appendData:packetHeadData];
    
    uint8_t endCommand=BLE_PROTOCOL_END_FLAG;
    [packetData appendBytes:&endCommand length:1];
    
    HETBLEProtocol* obj= [[self alloc] init];
    uint8_t byte[]={0};
    obj.singleDeviceResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.singleAppResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.packetData = packetData;
    return obj;

}
+(HETBLEProtocol *)getRequestConfirmUpgrade:(NSString *)uinqueIDString :(NSString *)deviceUpgradeVersion
{
    uint8_t packetHead[sizeof(Ble_Protocol_Head_T)]={0};
    uint8_t* uinqueID=(uint8_t*)[uinqueIDString UTF8String];
    Init_Ble_Protocol_Head(packetHead, REQUEST_CONFIRM_UPGRADE_COMMAND, 0,uinqueID,deviceUpgradeVersion);
    
    NSMutableData* packetData=[[NSMutableData alloc] initWithCapacity:0];
    NSData* packetHeadData=[NSData dataWithBytes:packetHead length:sizeof(Ble_Protocol_Head_T)];
    [packetData appendData:packetHeadData];
    
    uint8_t endCommand=BLE_PROTOCOL_END_FLAG;
    [packetData appendBytes:&endCommand length:1];
    
    HETBLEProtocol* obj= [[self alloc] init];
    uint8_t byte[]={0};
    obj.singleDeviceResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.singleAppResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.packetData = packetData;
    return obj;
}
/**
 *  根据新的蓝牙协议生成数据包
 *
 *  @param cmdNo          命令字
 *  @param uinqueIDString 唯一ID
 *
 *  @return 返回对应的包
 */
+ (NSData *)createNewBlePacketWithCmdno:(uint16_t)cmdNo withUinqueId:(NSString *)uinqueIDString{
    uint8_t packetHead[sizeof(Ble_Protocol_Head_New)] = {0};
    uint8_t *uniqueID = (uint8_t*)[uinqueIDString UTF8String];
    Init_Ble_Protocol_Head_New(packetHead, cmdNo, 0, uniqueID);
    NSMutableData* packetData=[[NSMutableData alloc] initWithCapacity:0];
    NSData* packetHeadData=[NSData dataWithBytes:packetHead length:sizeof(Ble_Protocol_Head_New)];
    [packetData appendData:packetHeadData];

    uint16_t data_fcr=0x0101;
    [packetData appendBytes:&data_fcr length:2];
    return packetData;
}

/**
 *  获取蓝牙协议数据包
 *
 *  @param uinqueIDString 唯一ID
 *
 *  @return 返回获取协议版本的数据包
 */
+(HETBLEProtocol *)getRequestProtocolVersion:(NSString *)uinqueIDString {
    /*NSData *packetData = [self createNewBlePacketWithCmdno:REQUEST_PROTOCOL_VERSION withUinqueId:uinqueIDString];
    if (packetData && packetData.length > 0) {
        return packetData;
    }
    return nil;*/
    
    
    uint8_t packetHead[sizeof(Ble_Protocol_Head_T)]={0};
    uint8_t* uinqueID=(uint8_t*)[uinqueIDString UTF8String];
    Init_Ble_Protocol_Head(packetHead, REQUEST_PROTOCOL_VERSION, 0,uinqueID,nil);
    
    NSMutableData* packetData=[[NSMutableData alloc] initWithCapacity:0];
    NSData* packetHeadData=[NSData dataWithBytes:packetHead length:sizeof(Ble_Protocol_Head_T)];
    [packetData appendData:packetHeadData];
    
    uint8_t endCommand=BLE_PROTOCOL_END_FLAG;
    [packetData appendBytes:&endCommand length:1];
    
    HETBLEProtocol* obj= [[self alloc] init];
    uint8_t byte[]={0};
    obj.singleDeviceResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.singleAppResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.packetData = packetData;
    return obj;
    

}

/**
 *  获取蓝牙当前数据包
 *
 *  @param uinqueIDString 唯一ID
 *
 *  @return 返回对应数据包
 */
+ (NSData *)getRequestKeyData:(NSString *)uinqueIDString {
    NSData *packetData = [self createNewBlePacketWithCmdno:REQUEST_KEY_DATA withUinqueId:uinqueIDString];
    if (packetData && packetData.length > 0) {
        return packetData;
    }
    return nil;
}

/**
 *  获取蓝牙同步数据包
 *
 *  @param uinqueIDString 唯一ID
 *
 *  @return 返回对应数据包
 */
+ (HETBLEProtocol *)getRequestSyncData:(NSString *)uinqueIDString {
    NSData *packetData = [self createNewBlePacketWithCmdno:REQUEST_SYNC_DATA withUinqueId:uinqueIDString];
    if (packetData && packetData.length > 0) {

        HETBLEProtocol* obj= [[self alloc] init];
        uint8_t byte[]={0};
        obj.singleAppResponsePacketData = [NSData dataWithBytes:byte length:1];
        obj.packetData = packetData;
        return obj;
    }
    return nil;
}

/**
 *  获取蓝牙绑定数据包
 *
 *  @param uinqueIDString 唯一ID
 *
 *  @return 返回对应数据包
 */
+ (NSData *)getRequestBleBindData:(NSString *)uinqueIDString {
    NSData *packetData = [self createNewBlePacketWithCmdno:REQUEST_BIND_BLE_DEVICE withUinqueId:uinqueIDString];
    if (packetData && packetData.length > 0) {
        return packetData;
    }
    return nil;
}
+(HETBLEProtocol *)getRequestPacketData:(NSString*)uinqueIDString withContentData:(NSData *)contentData
                             withComdNO:(short)comdNO
          withDeviceResponsePacketData :(NSData*)deviceResponsePacketData
               wihAppResponsePacketData:(NSData *)appResponsePacketData

{
    NSUInteger contentLength=contentData.length;
    uint8_t packetHead[sizeof(Ble_Protocol_Head_T)]={0};
    uint8_t* uinqueID=(uint8_t*)[uinqueIDString UTF8String];
    
    Init_Ble_Protocol_Head(packetHead, comdNO, contentLength,uinqueID,nil);
    
    
    NSMutableData* packetData=[[NSMutableData alloc] initWithCapacity:0];
    NSData* packetHeadData=[NSData dataWithBytes:packetHead length:sizeof(Ble_Protocol_Head_T)];
    [packetData appendData:packetHeadData];
    
    if(contentData)
    {
        [packetData appendData:contentData];
    }
    
    uint8_t endCommand=BLE_PROTOCOL_END_FLAG;
    [packetData appendBytes:&endCommand length:1];
    
    HETBLEProtocol* obj= [[self alloc] init];
    //uint8_t byte[]={0};
    if(deviceResponsePacketData)
    {
        obj.singleDeviceResponsePacketData=deviceResponsePacketData;
    }
    if(appResponsePacketData)
    {
        obj.singleAppResponsePacketData =appResponsePacketData;
    }
    
    //obj.singleDeviceResponsePacketData = [NSData dataWithBytes:byte length:1];
    //obj.singleAppResponsePacketData = [NSData dataWithBytes:byte length:1];
    obj.packetData = packetData;
    return obj;

}
//解析数据
+(HETBLEReform*)transformData:(NSData *)data
{
    HETBLEReform *obj = [[HETBLEReform alloc] init];

    uint8_t* packet_Ble_Data=malloc(data.length);
    NSData* tempData=[[NSData alloc] initWithData:data];
    [tempData getBytes:packet_Ble_Data length:data.length];

    Ble_Protocol_Packet_T* packet_t=malloc(sizeof(Ble_Protocol_Packet_T));
    packet_t->head=malloc(sizeof(Ble_Protocol_Head_T));

    //解析包头（1字节）（起始标志0xf2）
    uint8_t startFlag=packet_Ble_Data[0];
    if (startFlag!=0xf2) {

        NSLog(@"解析数据出错,包头不是0xf2");
        
        //置0（packet_t->head中前sizeof(Ble_Protocol_Head_T)个字节,用0替换并返回packet_t->head）
        memset(packet_t->head, 0, sizeof(Ble_Protocol_Head_T));
        //释放内存
        free(packet_t->head);
        memset(packet_t, 0, sizeof(Ble_Protocol_Packet_T));
        free(packet_t);
        memset(packet_Ble_Data, 0, data.length);
        free(packet_Ble_Data);

        return nil;
    }
    packet_t->head->startflag=startFlag;

    
    //解析终端软件版本号（2字节）
    uint16_t devcieSoftVer;
    memcpy(&devcieSoftVer, packet_Ble_Data+1, 2);//从源packet_Ble_Data+1所指的内存地址的起始位置开始拷贝2个字节到目标devcieSoftVer所指的内存地址的起始位置中
    devcieSoftVer=htons(devcieSoftVer);
    packet_t->head->device_software_version = devcieSoftVer;
//    memcpy(&(packet_t->head->device_software_version), devcieSoftVer, sizeof(devcieSoftVer));

    //解析协议版本号（2字节）
    uint16_t protocolVersion;
    memcpy(&protocolVersion, packet_Ble_Data+3, 2);
    protocolVersion=htons(protocolVersion);
    packet_t->head->protocol_version=protocolVersion;

    //解析数据加密类型（1字节）
    uint8_t encryptCategories=packet_Ble_Data[5];
    packet_t->head->encrypt_category=encryptCategories;

    //解析命令字（2字节）
    uint16_t comdNo=0;
    memcpy(&comdNo, packet_Ble_Data+6, 2);
    comdNo=htons(comdNo);
    packet_t->head->cmd_no=comdNo;

     //解析设备唯一ID（6字节）
    uint8_t uniqueID[6]={0};
    memcpy(uniqueID, packet_Ble_Data+8, 6);
    memcpy(packet_t->head->uniqueID, uniqueID, sizeof(uniqueID));

    //解析时区（1字节）
    uint8_t timeZone=packet_Ble_Data[14];
    packet_t->head->timezone=timeZone;

    //解析协议时间（7字节）
    uint8_t protocolDate[7]={0};
    memcpy(protocolDate, packet_Ble_Data+15, 7);
    memcpy(packet_t->head->time, protocolDate, sizeof(protocolDate));

    //解析数据长度（2字节）
    uint16_t dataLength=0;
    memcpy(&dataLength, packet_Ble_Data+22, 2);
    dataLength=htons(dataLength);
    packet_t->head->body_length=dataLength;

    //解析数据
    uint8_t* bodyData=malloc(dataLength);
    memcpy(bodyData, packet_Ble_Data+24, dataLength);

    
    //解析结束标志（1字节）（0xf3）
    uint8_t endFlag=0;
    memcpy(&endFlag, packet_Ble_Data+24+dataLength, sizeof(uint8_t));
    if (endFlag!=0xf3) {

        memset(packet_t->head, 0, sizeof(Ble_Protocol_Head_T));
        free(packet_t->head);
        memset(packet_t, 0, sizeof(Ble_Protocol_Packet_T));
        free(packet_t);
        memset(packet_Ble_Data, 0, data.length);
        free(packet_Ble_Data);
        memset(bodyData, 0, dataLength);
        free(bodyData);
        NSLog(@"解析数据出错,包尾不是0xf3");

        return nil;
    }
    packet_t->body=malloc(dataLength);
    memcpy(packet_t->body, bodyData, dataLength);

    
    //赋值
    obj.startflag = packet_t->head->startflag;
    obj.device_software_version = packet_t->head->device_software_version;
    obj.protocol_version = packet_t->head->protocol_version;
    obj.encrypt_category = packet_t->head->encrypt_category;
    obj.cmd_no = packet_t->head->cmd_no;
    obj.uniqueID = [NSData dataWithBytes:uniqueID length:6];
    obj.timezone = packet_t->head->timezone;
    obj.time = [NSData dataWithBytes:protocolDate length:7];
    obj.body_length = packet_t->head->body_length;
    obj.body  = [NSData dataWithBytes:packet_t->body length:packet_t->head->body_length];
    obj.endflag  = packet_t->endflag;

    
    //清0并释放内存
    memset(packet_t->body, 0, dataLength);
    free(packet_t->body);
    memset(packet_t->head, 0, sizeof(Ble_Protocol_Head_T));
    free(packet_t->head);
    memset(packet_t, 0, sizeof(Ble_Protocol_Packet_T));
    free(packet_t);
    memset(packet_Ble_Data, 0, data.length);
    free(packet_Ble_Data);
    memset(bodyData, 0, dataLength);
    free(bodyData);

    //返回解析后的数据
    return obj;
}

//-(reformDataBlock)reformDataBlock
//{
//    __weak  BLEMattressProtocol * weakself = self;
//    reformDataBlock block = ^(NSData*data){
//        self.reformData = [weakself transformData:data];
//        return ;
//    };
//    return  [block copy];
//}
@end
