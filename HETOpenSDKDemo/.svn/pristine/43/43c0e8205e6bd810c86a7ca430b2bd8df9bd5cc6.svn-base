//
//  CLBLEDataRequest.m
//  BLEForCSleep
//
//  Created by Sandy wu on 15/6/4.
//  Copyright (c) 2015年 Het. All rights reserved.
//

#import "CLBLEBaseApi.h"
#import "LGBluetooth.h"
#import "CSleepBlueToothDefine.h"
#import "CLBLEManager.h"
static const int TimeOutInterval=5;

@interface CLBLEBaseApi()
{
    BOOL  _bFirstRecv;
}

//成功block
@property (copy,nonatomic) BLESuccessBlock successBlock;

//失败block
@property (copy,nonatomic) BLEFailBlock failBlock;

@property (strong,nonatomic) LGCharacteristic* writeCharacteristic;

@property (strong,nonatomic) LGCharacteristic* readCharacteristic;

@property (nonatomic,weak) id<CLBLEPacketHandle> dataPacketHandleDelegate;

@property (nonatomic,strong) NSData* rawBLEData;

@property (nonatomic,copy)BLEProgressiveDownLoadBlock progressBlock;
@end

@implementation CLBLEBaseApi

#pragma mark - life cycle
-(void)dealloc{
    NSLog(@"CLBLEBaseApi dealloc");
}

-(id)initBLEManagerWithStateBlock:(void(^)(CBCentralManagerState state))stateBlock{
    if (self =[self init]) {
//        _bleManager=[[BLEManager alloc] initBLEManagerWithStateBlock:^(CBCentralManagerState state) {
//            stateBlock(state);
//        }];
    }
    return self;
}

-(instancetype)init{
    self=[super init];
    if (self) {
        if ([self conformsToProtocol:@protocol(CLBLEDataSource)]) {
            self.child=(id <CLBLEDataSource>)self;

        }
    }
    return self;
}



-(id)initWithBroadName:(NSString *)broadName{
    if ([super init]) {
//        self.BLEBroadName=broadName;
    }
    return self;
}

#pragma mark - public Method
-(BLEProgressiveDownLoadBlock)progressBlock
{
    if(_progressBlock)
        return _progressBlock;
    return   [^(NSInteger totalBytesRead, NSInteger totalBytesExpected){} copy];
}
-(void)setProgressiveBlock:(BLEProgressiveDownLoadBlock)progressBlock
{
    self.progressBlock = progressBlock;
}

-(void)sendBLEDataWithDataPacketProtocol:(id<CLBLEPacketHandle>)packetDelegate
                                 Success:(BLESuccessBlock)successBlock
                                    fail:(BLEFailBlock)failBlock{
    if (self.state!= CLBLEStateIdle) {
        NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEBusyErrorCode userInfo:@{@"message":kBLEBusyErrorCodeErrorMessage}];
        failBlock(error);
        return;
    }
    self.child=(id <CLBLEDataSource>)self;

    if (!self.child.connectedPeripheral) {
        NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEObjErrorCode userInfo:@{@"message":kBLEObjErrorCodeErrorMessage}];
        failBlock(error);
        return;
    }
    if (self.child.connectedPeripheral.cbPeripheral.state!=CBPeripheralStateConnected) {
        //NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLECommunConnectErrorCode userInfo:@{@"message":@"设备没有连接，发个毛啊！"}];
        NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLECommunConnectErrorCode userInfo:@{@"message":kBLECommunConnectErrorCodeErrorMessage}];
        failBlock(error);
        return;
    }
    self.dataPacketHandleDelegate=packetDelegate;
    [self sendBLEDataWithData:[self.dataPacketHandleDelegate fetchCompletePacketData]
                      Success:successBlock
                         fail:failBlock];
}

#pragma mark - private Method
-(void)sendBLEDataWithData:(NSData*)data
                   Success:(BLESuccessBlock)successBlock
                      fail:(BLEFailBlock)failBlock{
    [self setCompletionBlockWithSuccess:successBlock failure:failBlock];
    [self sendBLEData:data];
}
/*-(void)sendBLEDataWithData:(NSData*)data
        dataPacketProtocol:(id<CLBLEDataPacket>)packetDelegate
                   Success:(BLESuccessBlock)successBlock
                      fail:(BLEFailBlock)failBlock
{
    [self setCompletionBlockWithSuccess:successBlock failure:failBlock];
    [self sendBLEData:data];
}*/
- (void)setCompletionBlockWithSuccess:(BLESuccessBlock)success
                              failure:(BLEFailBlock)failure{
    self.successBlock=success;
    self.failBlock=failure;
}



-(void)sendBLEData:(NSData*)data{
    if (self.state!=CLBLEStateIdle) {
        NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEBusyErrorCode userInfo:@{@"message":kBLEBusyErrorCodeErrorMessage,@"state":@(self.state)}];
        self.failBlock(error);
        return;
    }
    __weak CLBLEBaseApi* weakSelf=self;

    if (!self.readCharacteristic) {
        NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEReadCharactErrorCode userInfo:@{@"message":kBLEReadCharactErrorCodeErrorMessage,@"state":@(self.state)}];
        self.failBlock(error);
        return;
    }
    else{
        if (self.readCharacteristic.cbCharacteristic.isNotifying) {
            self.readCharacteristic.updateCallback=^(NSData *data, NSError *error) {
                __strong CLBLEBaseApi* strongSelf=weakSelf;
                if (error) {
                    strongSelf.failBlock(error);
                }
                else{
                    [strongSelf receiveBLEData:data];
                };
            };
            [self sendDataMethod];
        }
        else{
            [self.readCharacteristic setNotifyValue:YES
                                         completion:^(NSError *error) {
                                             __strong CLBLEBaseApi* strongSelf=weakSelf;
                                             if (error) {
                                                 strongSelf.failBlock(error);
                                             }
                                             else{
                                                 [strongSelf sendDataMethod];
                                             }
                                         } onUpdate:^(NSData *data, NSError *error) {
                                             __strong CLBLEBaseApi* strongSelf=weakSelf;
                                             if (error) {
                                                 strongSelf.failBlock(error);
                                             }
                                             else{
                                                 [strongSelf receiveBLEData:data];
                                             }
                                         }];
        }

    }


//    [self.dataPacketHandleDelegate setPacketData:data];
//    self.receiveDataHelper=[[BLEReceiveDataHelper alloc] init];
//    __weak CLBLEBaseManagerApi* weakSelf=self;
//    [self.bleManager scanbleWithObject:self.child
//                       withScanTimeOut:3
//                   scanPeripheralBlock:^(NSArray *peripherals, NSError *error) {
//                       __strong CLBLEBaseManagerApi* strongSelf=weakSelf;
//                       for (LGPeripheral* peripheral in peripherals) {
//                           //NSLog(@"---%@--%@---%@---",weakSelf,peripheral.name,weakSelf);
//                           if ([peripheral.name isEqualToString:[strongSelf.child broadName]]) {
//                               strongSelf.activePeripheral=peripheral;
//                               [strongSelf sendDataMethod];
//                           }
//                       }
//                   } withReadDataBlock:^(NSData *data, NSError *error) {
//                       __strong CLBLEBaseManagerApi* strongSelf=weakSelf;
//                       [strongSelf receiveBLEData:data];
//                   }];


}

-(NSData*)receiveBLEData:(NSData*)data{
//    if (self.state==CLBLEStateSending) {
//        [self sendDataMethod];
//    }
//    else if(self.state==CLBLEStateReceiving){
//        [self receiveDataMethod:data];
//    }
    //存储接收数据
    //NSLog(@"receive data is %@",data);
    [self receiveDataMethod:data];
    return nil;
}

/*-(void)sendDataMethod{
    NSData* singleData=[self.dataPacketHandleDelegate fetchSinglePacketData];
    NSLog(@"拆包数据:%@",singleData);
    if (singleData) {
        _state=CLBLEStateSending;
        [self writeToCharacterWithValue:singleData];
        NSLog(@"当前发送数据包:%@",singleData);
        if([self.dataPacketHandleDelegate respondsToSelector:@selector(singlePacketDataDeviceResponse)])
        {
            NSData *data=[self.dataPacketHandleDelegate singlePacketDataDeviceResponse];
            
            if(data)
            {
                NSLog(@"APP等待设备回复的数据:%@",data);
                [self startTimeOut];
            }
            else
            {
                
                [NSTimer scheduledTimerWithTimeInterval:0.1f target:self selector:@selector(sendDataMethod) userInfo:nil repeats:NO];
            }
        }
        else
        {
            NSLog(@"APP不需要等待设备回复的数据");

            [NSTimer scheduledTimerWithTimeInterval:0.1f target:self selector:@selector(sendDataMethod) userInfo:nil repeats:NO];
        }
        
        
    }
    else{
        NSLog(@"发送数据已经完成，开始接收数据");
        [self startTimeOut];
        _state=CLBLEStateReceiving;
        
        
    }
}*/
-(void)sendDataMethod{
    NSData* singleData=[self.dataPacketHandleDelegate fetchSinglePacketData];
    //NSLog(@"拆包数据:%@,%d",singleData,[self.dataPacketHandleDelegate fetchPacketDataSendOver]);
    if (singleData) {
        _state=CLBLEStateSending;
        [self writeToCharacterWithValue:singleData];
        //NSLog(@"当前发送数据包:%@",singleData);
        if([self.dataPacketHandleDelegate respondsToSelector:@selector(singlePacketDataDeviceResponse)])
        {
            NSData *data=[self.dataPacketHandleDelegate singlePacketDataDeviceResponse];
            
            if(data)
            {
                NSLog(@"APP等待设备回复的数据:%@",data);
                [self startTimeOut];
            }
            else
            {
                if([self.dataPacketHandleDelegate fetchPacketDataSendOver])//最后一包数据
                {
                    NSLog(@"发送数据已经完成，开始接收数据");
                    [self startTimeOut];
                    _bFirstRecv=YES;
                    _state=CLBLEStateReceiving;
                    
                }
                else
                {
                    _bFirstRecv=FALSE;
                    [NSTimer scheduledTimerWithTimeInterval:0.1f target:self selector:@selector(sendDataMethod) userInfo:nil repeats:NO];
                }
            }
        }
        else
        {
            NSLog(@"APP不需要等待设备回复的数据");
            if([self.dataPacketHandleDelegate fetchPacketDataSendOver])//最后一包数据
            {
                NSLog(@"发送数据已经完成，开始接收数据");
                [self startTimeOut];
                _bFirstRecv=YES;
                _state=CLBLEStateReceiving;
            }
            else
            {
                _bFirstRecv=FALSE;
                [NSTimer scheduledTimerWithTimeInterval:0.1f target:self selector:@selector(sendDataMethod) userInfo:nil repeats:NO];
            }
        }
        
        
    }
    else{
        NSLog(@"发送数据已经完成，开始接收数据");
        [self startTimeOut];
        _bFirstRecv=YES;
        _state=CLBLEStateReceiving;
        
        
    }
}


-(void)sendSinglePacketResponse{
    //NSLog(@"sendSinglePacketResponse:状态:%d",(int)_state);
    if([self.dataPacketHandleDelegate respondsToSelector:@selector(singlePacketDataAppResponse)])
    {
        NSData* singleAppResponse=[self.dataPacketHandleDelegate singlePacketDataAppResponse];
        
        if (singleAppResponse) {
            NSLog(@"APP回复设备的数据:%@",singleAppResponse);
            [self writeToCharacterWithValue:singleAppResponse];
        }
    }
    [self startTimeOut];
    //    uint8_t result=0;
    //    NSData* dataResult=[NSData dataWithBytes:&result length:1];
    
}

/*-(void)receiveDataMethod:(NSData*)data{
    NSLog(@"receiveDataMethod:%@,%d,状态:%d",data,(int)data.length,(int)_state);
    if(_state==CLBLEStateSending)
    {
        
        //如果接受的数据为0或者00
        if(data.length==1||data.length==2)
        {
            NSLog(@"如果接受的数据为00");
            if([self.dataPacketHandleDelegate respondsToSelector:@selector(singlePacketDataDeviceResponse)])
            {
                NSData *correctData=[self.dataPacketHandleDelegate singlePacketDataDeviceResponse];
                NSMutableData *newData=[[NSMutableData alloc]init];
                [newData appendData:correctData];
                [newData appendData:correctData];
                
                if([data isEqualToData:correctData]||[newData isEqualToData:data])
                {
                    [self cancelTimeOut];
                    [self sendDataMethod];//拆多包发送
                }
            }
        }
        else  //如果接受的数据为00F2
        {
            NSLog(@"如果接受的数据为00F2");
            NSData* singleData=[self.dataPacketHandleDelegate fetchSinglePacketData];
            //NSLog(@"下一包数据:%@",singleData);
            if([self.dataPacketHandleDelegate respondsToSelector:@selector(singlePacketDataDeviceResponse)]&&!singleData)
            {
                Byte charf[1];
                charf[0]=0xF2;
                NSMutableData *newData=[[NSMutableData alloc]init];
                NSData *correctData=[self.dataPacketHandleDelegate singlePacketDataDeviceResponse];
                [newData appendData:correctData];
                [newData appendBytes:&charf length:1];
                
                
                if([[data description]rangeOfString:[newData description]].length)
                {
                    
                    NSData *dataToFind=[NSData dataWithBytes:&charf length:1];
                    NSRange indexOfData = [data rangeOfData: dataToFind options:0 range:NSMakeRange(0, data.length)];
                    NSData *appnewData=nil;
                    if(indexOfData.location!=NSNotFound)
                    {
                        appnewData=[data subdataWithRange:NSMakeRange(indexOfData.location, data.length-indexOfData.location)];
                    }
                    else
                    {
                        appnewData=data;
                    }
                    
                    NSError* error=nil;
                    NSData* parseData=[self.dataPacketHandleDelegate receiveAndParseData:appnewData error:&error];
                    
                    // po parseData <f2040000 0000a031 d05fb82a c62e1407 df091105 352c0000 f3>
                    
                    NSInteger receiveLenth = [self.dataPacketHandleDelegate receivedPacketDataLength];
                    NSInteger totalLenth = [self.dataPacketHandleDelegate totalPacketDataLength];
                    if (totalLenth!=0 && receiveLenth<=totalLenth) {
                        dispatch_async(dispatch_get_main_queue(), ^{
                            self.progressBlock(receiveLenth,totalLenth);
                        });
                    }
                    if (error==nil) {
                        if (parseData) {
                            //                [self sendSinglePacketResponse];
                            [self cancelTimeOut];
                            
                            if (self.successBlock) {
                                if ([self.dataPacketHandleDelegate respondsToSelector:@selector(apiManager:reformData:)]) {
                                    //                        [self.dataPacketHandleDelegate apiManager:self reformData:self.rawBLEData];
                                }
                                self.successBlock(parseData);
                                _state=CLBLEStateIdle;
                            }
                        }
                        else{
                            [self cancelTimeOut];
                            [self sendSinglePacketResponse];
                            //                   [self startTimeOut];
                        }
                    }
                    else{
                        //解析直接失败鸟。。
                        NSLog(@"解析失败 error is %@",error);
                        _state=CLBLEStateIdle;
                        [self cancelTimeOut];
                        NSError *error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLERecvDataErrorCode userInfo:@{@"message":kBLERecvDataErrorCodeErrorMessage}];

                        self.failBlock(error);
                    }
                    
                    
                    
                    
                    
                }
            }
            
        }
        
    }
    else if(_state==CLBLEStateReceiving)
    {
        NSError* error=nil;
        NSData* parseData=[self.dataPacketHandleDelegate receiveAndParseData:data error:&error];
        
        // po parseData <f2040000 0000a031 d05fb82a c62e1407 df091105 352c0000 f3>
        
        NSInteger receiveLenth = [self.dataPacketHandleDelegate receivedPacketDataLength];
        NSInteger totalLenth = [self.dataPacketHandleDelegate totalPacketDataLength];
        if (totalLenth!=0 && receiveLenth<=totalLenth) {
            dispatch_async(dispatch_get_main_queue(), ^{
                self.progressBlock(receiveLenth,totalLenth);
            });
        }
        
        if (error==nil) {
            if (parseData) {
                //                [self sendSinglePacketResponse];
                [self cancelTimeOut];
                
                if (self.successBlock) {
                    if ([self.dataPacketHandleDelegate respondsToSelector:@selector(apiManager:reformData:)]) {
                        //                        [self.dataPacketHandleDelegate apiManager:self reformData:self.rawBLEData];
                    }
                    self.successBlock(parseData);
                    _state=CLBLEStateIdle;
                }
            }
            else{
                [self cancelTimeOut];
                [self sendSinglePacketResponse];
                //[self startTimeOut];
            }
        }
        else{
            //解析直接失败鸟。。
            NSLog(@"解析失败 error is %@",error);
            _state=CLBLEStateIdle;
            [self cancelTimeOut];
            NSError *error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLERecvDataErrorCode userInfo:@{@"message":kBLERecvDataErrorCodeErrorMessage}];
            self.failBlock(error);
        }
    }
}

*/
-(void)receiveDataMethod:(NSData*)data{
    //NSLog(@"receiveDataMethod:%@,%d,状态:%d",data,(int)data.length,(int)_state);
    if(_state==CLBLEStateSending)
    {
        
        //如果接受的数据为0
        if(data.length==1||data.length==2)
        {
            //NSLog(@"如果接受的数据为00");
            if([self.dataPacketHandleDelegate respondsToSelector:@selector(singlePacketDataDeviceResponse)])
            {
                NSData *correctData=[self.dataPacketHandleDelegate singlePacketDataDeviceResponse];
                NSMutableData *newData=[[NSMutableData alloc]init];
                [newData appendData:correctData];
                [newData appendData:correctData];
                
                if([data isEqualToData:correctData]||[newData isEqualToData:data])
                {
                    [self cancelTimeOut];
                    [self sendDataMethod];//拆多包发送
                }
            }
        }
        else
        {
            
            
            
        }
        
    }
    else if(_state==CLBLEStateReceiving)
    {
        
        
        Byte charf[1];
        charf[0]=0xF2;
        NSMutableData *newData=[[NSMutableData alloc]init];
        NSData *correctData=[self.dataPacketHandleDelegate singlePacketDataDeviceResponse];
        [newData appendData:correctData];
        [newData appendBytes:&charf length:1];
        NSData *appnewData=data;
        if([[data description]rangeOfString:[newData description]].location==0 &&_bFirstRecv)//开始接收第一包数据 ，回应数据00跟F2粘包 ，需要提取F2之后数据
        {
            //NSLog(@"如果接受的数据为00F2");
            NSData *dataToFind=[NSData dataWithBytes:&charf length:1];
            NSRange indexOfData = [data rangeOfData: dataToFind options:0 range:NSMakeRange(0, data.length)];
            
            if(indexOfData.location!=NSNotFound)
            {
                appnewData=[data subdataWithRange:NSMakeRange(indexOfData.location, data.length-indexOfData.location)];
            }
            
        }
        if(_bFirstRecv)
        {
            _bFirstRecv=FALSE; //获取历史数据包中有可能第N包数据开头也是回应数据00跟F2  ，此时不需做数据截取
        }
        NSError* error=nil;
        NSData* parseData=[self.dataPacketHandleDelegate receiveAndParseData:appnewData error:&error];
        
        // po parseData <f2040000 0000a031 d05fb82a c62e1407 df091105 352c0000 f3>
        
        NSInteger receiveLenth = [self.dataPacketHandleDelegate receivedPacketDataLength];
        NSInteger totalLenth = [self.dataPacketHandleDelegate totalPacketDataLength];
        if (totalLenth!=0 && receiveLenth<=totalLenth) {
            dispatch_async(dispatch_get_main_queue(), ^{
                self.progressBlock(receiveLenth,totalLenth);
            });
        }
        
        if (error==nil) {
            if (parseData) {
                //                [self sendSinglePacketResponse];
                [self cancelTimeOut];
                
                if (self.successBlock) {
                    if ([self.dataPacketHandleDelegate respondsToSelector:@selector(apiManager:reformData:)]) {
                        //                        [self.dataPacketHandleDelegate apiManager:self reformData:self.rawBLEData];
                    }
                    self.successBlock(parseData);
                    _state=CLBLEStateIdle;
                }
            }
            else{
                [self cancelTimeOut];
                [self sendSinglePacketResponse];
                //                   [self startTimeOut];
            }
        }
        else{
            //解析直接失败鸟。。
            NSLog(@"解析失败 error is %@",error);
            _state=CLBLEStateIdle;
            [self cancelTimeOut];
            self.failBlock(error);
        }
    }
}

-(void)writeToCharacterWithValue:(NSData*)data{
//    NSLog(@"send data is %@",data);
    [self.writeCharacteristic writeValue:data completion:nil];
}

-(void)timeOutAction{
    _state=CLBLEStateIdle;
    NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLETimeOutErrorCode userInfo:@{@"message":kBLETimeOutErrorCodeErrorMessage}];
    self.failBlock(error);
}

-(void)startTimeOut{
    [self performSelector:@selector(timeOutAction)
               withObject:nil
               afterDelay:TimeOutInterval];
}

-(void)cancelTimeOut{
    [NSObject cancelPreviousPerformRequestsWithTarget:self
                                             selector:@selector(timeOutAction)
                                               object:nil];
}


#pragma mark- getter and setter

-(BOOL)bleIsReady{
    if (self.readCharacteristic&&self.writeCharacteristic) {
        return YES;
    }
    else{
        return NO;
    }
}

-(LGCharacteristic*)writeCharacteristic{
//    if (!_writeCharacteristic) {
        for (LGService* service in self.child.connectedPeripheral.services) {
            if ([service.UUIDString isEqualToString:[self.child writeSeriveID]]) {
                for (LGCharacteristic* character in service.characteristics) {
                    if ([[character.UUIDString uppercaseString] isEqualToString:[[self.child writeCharacteristicID]uppercaseString]]) {
                        _writeCharacteristic=character;
                    }
                }
            }

        }
//    }
    return _writeCharacteristic;
}

-(LGCharacteristic*)readCharacteristic{
//    if (!_readCharacteristic) {
        for (LGService* service in self.child.connectedPeripheral.services) {

            for (LGCharacteristic* character in service.characteristics) {
                 NSLog(@"%@,%@",character.UUIDString,[self.child readCharacteristicID]);

                if ([[character.UUIDString uppercaseString] isEqualToString:[[self.child readCharacteristicID]uppercaseString]]) {
                    _readCharacteristic=character;
                }
            }

        }
//    }
    return _readCharacteristic;
}
@end
