//  HETNetWorkRequest.m
//  openSDK
//
//
//  Created by peng on 6/25/15.
//  Copyright (c) 2015 peng All rights reserved.
//

#import "HETNetWorkRequest.h"
#import "HETURLRequestHelper.h"
#import "HETAccounts.h"
#import <commonCrypto/CommonDigest.h>

#import "NSDate+SSToolkitAdditions.h"

//#define kHETAPIBaseUrl @"https://200.200.200.50/v1/app/open"//@"https://test.open.api.clife.cn/v1"
//#define kHETUploadAPIBaseUrl @"https://200.200.200.50/v1/app/open"//@"https://test.open.api.clife.cn/v1"
@interface HETNetWorkRequest ()


@property (nonatomic, strong) NSOperationQueue *requestQueue;
@property (nonatomic, weak) NSOperation *lastAddedOperation;

@property (nonatomic, strong) dispatch_queue_t workingQueue;
@property (nonatomic, strong) dispatch_queue_t barrierQueue;

@end


@implementation HETNetWorkRequest
{
    dispatch_semaphore_t _sema;
}


+ (HETNetWorkRequest *)shared
{
    static dispatch_once_t once;
    static HETNetWorkRequest *instance=nil;
    dispatch_once(&once, ^{
        instance = self.new;
        instance ->_sema = dispatch_semaphore_create(1);
    });
    return instance;
}

- (id)init
{
    if ((self = [super init]))
    {
        _requestQueue = NSOperationQueue.new;
        _requestQueue.maxConcurrentOperationCount = 4;
        _workingQueue = dispatch_queue_create("com.HETSDK.HETNetRequest", DISPATCH_QUEUE_SERIAL);
        _barrierQueue = dispatch_queue_create("com.HETSDK.HETNetRequestBarrierQueue", DISPATCH_QUEUE_CONCURRENT);
        if ([[HETAccounts shared] currentAccount]) { // Get current users's access token;
            self.accessToken = [[HETAccounts shared]currentAccount].accessToken;
        }
    }
    return self;
}

- (void)dealloc
{
    [self.requestQueue cancelAllOperations];
}

- (void)setMaxConcurrentDownloads:(NSInteger)maxConcurrentDownloads
{
    _requestQueue.maxConcurrentOperationCount = maxConcurrentDownloads;
}

- (NSInteger)maxConcurrentDownloads
{
    return _requestQueue.maxConcurrentOperationCount;
}

- (HETNetWorkRequestOperation*)requestWithURLRequest:(NSURLRequest *)request
                                    BlockWithSuccess:(SuccessBlock)success
                                             failure:(FailureBlock)failure;
{
    
    
   
    
    __block HETNetWorkRequestOperation *operation;
    __weak HETNetWorkRequest *wself = self;
    //dispatch_barrier_async(self.barrierQueue, ^{
        operation=[[HETNetWorkRequestOperation alloc]initWithRequest:request queue:wself.workingQueue BlockWithSuccess:^(HETNetWorkRequestOperation *operation, id responseObject) {
            success(operation,responseObject);
            
        } failure:^(HETNetWorkRequestOperation *operation, NSError *error) {
            failure(operation,error);
        }];
        [wself.requestQueue addOperation:operation];
        //LIFO
        [wself.lastAddedOperation addDependency:operation];
        wself.lastAddedOperation = operation;

  //  });
    return operation;
}


-(void)startRequestWithHTTPMethod: (HETRequestMethod)method  withRequestUrl:(NSString *)requestUrl processParams:(NSDictionary *)params needSign:(BOOL)needSign
                 BlockWithSuccess:(SuccessBlock)success
                          failure:(FailureBlock)failure{
    HETAccount *account=[[HETAccounts shared]currentAccount];
    NSDate *refreshTime           = [NSDate date];
    //NSTimeZone *zone = [NSTimeZone systemTimeZone];
    
    //NSInteger interval = [zone secondsFromGMTForDate: refreshTime];
    
    //NSDate *localeDate = [refreshTime  dateByAddingTimeInterval: interval];
    
    //NSLog(@"%@,%@,%d", refreshTime,account.expirationDate,[refreshTime compare:account.expirationDate]);
    
    void (^requestAccessToken)()= ^(){
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            dispatch_semaphore_wait(_sema, DISPATCH_TIME_FOREVER);
            /**
             *  之所以判断[request.accessToken isEqualToString:[HETUserInfo userInfo].accessToken]，
             *  是因为当多个请求需要几乎同时请求token时，需要加锁，确保请求token时只有一个方法
             */
            NSString *accessToken = account.accessToken;
            if (![accessToken isEqualToString:[[HETAccounts shared]currentAccount].accessToken]) {
                /**
                 *  在解锁之后其他请求需要判断之前存储的token信息有没有更新，如果有，则不用再去请求token，直接那更新好的token就行
                 */
                accessToken =[[HETAccounts shared]currentAccount].accessToken;
                /**
                 *  在return之前确保锁是打开的
                 */
                dispatch_semaphore_signal(_sema);//发送一个信号
                if(method==HETRequestMethodGet)
                {
                    NSDictionary *processedParams =[self generateSignWithHTTPMethod:HETRequestMethodGet withRequestUrl:requestUrl processParams:params needSign:needSign];
                    NSLog(@"fullURL:%@,%@",requestUrl,params);
                    NSURLRequest *request = [HETURLRequestHelper getRequestWithUrl:requestUrl params:processedParams];
                    [self requestWithURLRequest:request BlockWithSuccess:success failure:failure];
                }
                else if (method==HETRequestMethodPost)
                {
                    NSDictionary *processedParams =[self generateSignWithHTTPMethod:HETRequestMethodPost withRequestUrl:requestUrl processParams:params needSign:needSign];
                    NSLog(@"fullURL:%@,%@",requestUrl,processedParams);
                    NSURLRequest *request = [HETURLRequestHelper postRequestWithUrl:requestUrl params:processedParams];
                    [self requestWithURLRequest:request BlockWithSuccess:success failure:failure];
                    
                }

                
                return;
            }
            
            if (![[HETAccounts shared]currentAccount].refreshToken) {
                NSError *err=[[NSError alloc]initWithDomain:NSStringFromClass([self class]) code:1000 userInfo:@{@"msg":@"当前账号的refreshToken为空"}];
                failure(nil,err);
                dispatch_semaphore_signal(_sema);
                return;
            }
            
            //NSLog(@"刷新token:%@,%@",[self refreshAcessTokenRequestUrl:account.refreshToken],account.accessToken);
            [self requestWithURLRequest:[self refreshAcessTokenRequestUrl:account.refreshToken] BlockWithSuccess:^(HETNetWorkRequestOperation *operation, id responseObject) {
                dispatch_semaphore_signal(_sema);
                NSDictionary *result = responseObject;
                NSInteger code= [[(NSDictionary *)result objectForKey:@"code"] integerValue];
                if (code!=0) {
                    NSLog(@"刷新token:%@",[(NSDictionary *)result objectForKey:@"msg"]);
                    NSError *error=[[NSError alloc]initWithDomain:NSStringFromClass([self class]) code:1000 userInfo:responseObject];
                    failure(operation,error);
                    return;
                    
                }
                /*
                 {
                 accessToken = 2124ae261f1e4cc490c2afdb059edea2;
                 accessTokenExpires = 28800;
                 refreshToken = dd134ba07a74463caf2ce1b38cbff12d;
                 refreshTokenExpires = 2592000;
                 };
*/
                NSDictionary *dict = [(NSDictionary *)result objectForKey:@"data"];
                NSString *accessToken   =  [dict objectForKey:@"accessToken"];
                NSString *openId        =  [dict objectForKey:@"openId"];
                NSString * expiresIn    =  [dict objectForKey:@"expiresIn"];
                NSString *refreshToken  =  [dict objectForKey:@"refreshToken"];
                NSString *refreshTokenExpires =[dict objectForKey:@"refreshTokenExpires"];
                
                if (accessToken.length > 0 && openId.length > 0) {
                    HETAccount *account = [HETAccount new];
                    account.accessToken = accessToken;
                    account.openId = openId;
                    account.refreshToken = refreshToken;
                    account.expirationDate = [NSDate dateWithTimeIntervalSinceNow:[expiresIn integerValue]];
                    account.refreshTokenDate=[NSDate dateWithTimeIntervalSinceNow:[refreshTokenExpires integerValue]];
                    
                    [[HETAccounts shared] addAccount:account];
                    [[HETNetWorkRequest shared] setAccessToken:accessToken];
                
                    
                    
                    if(method==HETRequestMethodGet)
                    {
                        NSDictionary *processedParams =[self generateSignWithHTTPMethod:HETRequestMethodGet withRequestUrl:requestUrl processParams:params needSign:needSign];
                        //NSLog(@"fullURL:%@,%@",requestUrl,params);
                        NSURLRequest *request = [HETURLRequestHelper getRequestWithUrl:requestUrl params:processedParams];
                        [self requestWithURLRequest:request BlockWithSuccess:success failure:failure];
                    }
                    else if (method==HETRequestMethodPost)
                    {
                        NSDictionary *processedParams =[self generateSignWithHTTPMethod:HETRequestMethodPost withRequestUrl:requestUrl processParams:params needSign:needSign];
                        //NSLog(@"fullURL:%@,%@",requestUrl,processedParams);
                        NSURLRequest *request = [HETURLRequestHelper postRequestWithUrl:requestUrl params:processedParams];
                        [self requestWithURLRequest:request BlockWithSuccess:success failure:failure];
                        
                    }
                    
                }
                else
                {
                    NSLog(@"刷新Token请求得到的数据为:%@!",responseObject);
                }
            
                
                
            } failure:^(HETNetWorkRequestOperation *operation, NSError *error) {
                NSLog(@"error:%@",error);
                dispatch_semaphore_signal(_sema);
                failure(operation,error);
                
            }];
            
            
        });
    };

    // accessToken尚未失效，直接访问
    if ([refreshTime compare:account.expirationDate]!=NSOrderedDescending) {
        
        if(method==HETRequestMethodGet)
        {
            NSDictionary *processedParams =[self generateSignWithHTTPMethod:HETRequestMethodGet withRequestUrl:requestUrl processParams:params needSign:needSign];
            //NSLog(@"fullURL:%@,%@",requestUrl,processedParams);
            NSURLRequest *request = [HETURLRequestHelper getRequestWithUrl:requestUrl params:processedParams];
            [self requestWithURLRequest:request BlockWithSuccess:^(HETNetWorkRequestOperation *operation, id responseObject){
                
                if([responseObject isKindOfClass:[NSDictionary class]])
                {
                    NSString *code=[responseObject objectForKey:@"code"];
                    if(code.intValue==0)
                    {
                        success(operation,responseObject);
                    }
                    else
                    {
                        if(code.intValue==100010101)//token过期
                        {
                            requestAccessToken();
                            
                            
                            
                        }
                        else
                        {
                           //NSLog(@"%@",[responseObject objectForKey:@"msg"]);
                          failure(operation,[NSError errorWithDomain:NSStringFromClass([self class]) code:1003 userInfo:responseObject]);
                        }
                        
                        
                        
                    }
                    
                }

            } failure:^(HETNetWorkRequestOperation *operation, NSError *error) {
                failure(operation,error);
            }];
        }
        else if (method==HETRequestMethodPost)
        {
            NSDictionary *processedParams =[self generateSignWithHTTPMethod:HETRequestMethodPost withRequestUrl:requestUrl processParams:params needSign:needSign];
            //NSLog(@"fullURL:%@,%@",requestUrl,processedParams);
            NSURLRequest *request = [HETURLRequestHelper postRequestWithUrl:requestUrl params:processedParams];
            [self requestWithURLRequest:request BlockWithSuccess:^(HETNetWorkRequestOperation *operation, id responseObject){
                
                if([responseObject isKindOfClass:[NSDictionary class]])
                {
                    NSString *code=[responseObject objectForKey:@"code"];
                    if(code.intValue==0)
                    {
                        success(operation,responseObject);
                    }
                    else
                    {
                        if(code.intValue==100010101)
                        {
                            requestAccessToken();
                        }
                        else
                        {
                            //NSLog(@"%@",[responseObject objectForKey:@"msg"]);
                            //failure([NSError errorWithDomain:@"deviceControl" code:1003 userInfo:responseObject]);
                            failure(operation,[NSError errorWithDomain:NSStringFromClass([self class]) code:1003 userInfo:responseObject]);
                        }
                        
                        
                        
                    }
                    
                }
                
            } failure:^(HETNetWorkRequestOperation *operation, NSError *error) {
                failure(operation,error);
            }];
            
        }
    }
    
    // accessToken失效，refreshToken未失效，刷新后再访问
    else /*if ((account.refreshToken!= nil)
             && ([refreshTime compare:account.expirationDate]==NSOrderedDescending)
             && ([refreshTime compare:account.refreshTokenDate]!=NSOrderedDescending))*/
    {
        // 刷新token
        /**
         *  异步去请求刷新token
         *
         */
       
        
        requestAccessToken();

    }

    
}


/*- (HETNetWorkRequestOperation*)getFromUrl:(NSString *)url
                              params:(NSDictionary *)params
                                 needSign:(BOOL)needSign
                         BlockWithSuccess:(SuccessBlock)success
                                  failure:(FailureBlock)failure{
    
    
    
    NSDictionary *processedParams =[self generateSignWithHTTPMethod:HETRequestMethodGet withRequestUrl:url processParams:params needSign:needSign];
      //NSLog(@"fullURL:%@,%@",url,params);
    NSURLRequest *request = [HETURLRequestHelper getRequestWithUrl:url params:processedParams];
    return [self requestWithURLRequest:request BlockWithSuccess:success failure:failure];
}

- (HETNetWorkRequestOperation*)postToUrl:(NSString *)url
                                  params:(NSDictionary *)params
                                needSign:(BOOL)needSign
                        BlockWithSuccess:(SuccessBlock)success
                                 failure:(FailureBlock)failure{
    NSDictionary *processedParams =[self generateSignWithHTTPMethod:HETRequestMethodPost withRequestUrl:url processParams:params needSign:needSign];
   // NSLog(@"url:%@,%@",url,processedParams);
    NSURLRequest *request = [HETURLRequestHelper postRequestWithUrl:url params:processedParams];
   return [self requestWithURLRequest:request BlockWithSuccess:success failure:failure];
}

- (HETNetWorkRequestOperation*)getFromPath:(NSString *)apiPath
                               params:(NSDictionary *)params
                             needSign:(BOOL)needSign
                          BlockWithSuccess:(SuccessBlock)success
                                   failure:(FailureBlock)failure{
    NSString * fullURL = [kHETAPIBaseUrl stringByAppendingString:apiPath];
  
    return [self getFromUrl:fullURL params:params needSign:needSign BlockWithSuccess:success failure:failure];
}

- (HETNetWorkRequestOperation*)postToPath:(NSString *)apiPath
                              params:(NSDictionary *)params
                            needSign:(BOOL)needSign
                         BlockWithSuccess:(SuccessBlock)success
                                  failure:(FailureBlock)failure {
    NSString * fullURL= [kHETAPIBaseUrl stringByAppendingString:apiPath];
    return [self postToUrl:fullURL params:params needSign:needSign BlockWithSuccess:success failure:failure];
}*/



-(void)startMultipartFormDataRequestWithRequestUrl:(NSString *)requestUrl processParams:(NSDictionary *)params
                                  BlockWithSuccess:(SuccessBlock)success
                                           failure:(FailureBlock)failure
{
    HETAccount *account=[[HETAccounts shared]currentAccount];
    // 请求参数
    NSMutableDictionary *param = params ? [NSMutableDictionary dictionaryWithDictionary:params] : [NSMutableDictionary dictionary];
    if (![param objectForKey:@"accessToken"] && self.accessToken) {
        [param setObject:self.accessToken forKey:@"accessToken"];
    }

    NSDate *refreshTime           = [NSDate date];
    
    
    void (^requestAccessToken)()= ^(){
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            dispatch_semaphore_wait(_sema, DISPATCH_TIME_FOREVER);
            /**
             *  之所以判断[request.accessToken isEqualToString:[HETUserInfo userInfo].accessToken]，
             *  是因为当多个请求需要几乎同时请求token时，需要加锁，确保请求token时只有一个方法
             */
            NSString *accessToken = account.accessToken;
            if (![accessToken isEqualToString:[[HETAccounts shared]currentAccount].accessToken]) {
                /**
                 *  在解锁之后其他请求需要判断之前存储的token信息有没有更新，如果有，则不用再去请求token，直接那更新好的token就行
                 */
                accessToken =[[HETAccounts shared]currentAccount].accessToken;
                /**
                 *  在return之前确保锁是打开的
                 */
                dispatch_semaphore_signal(_sema);//发送一个信号
                NSURLRequest *request = [HETURLRequestHelper postMultipartFormDataRequestWithUrl:requestUrl params:param];
                [self requestWithURLRequest:request BlockWithSuccess:success failure:failure];
                
                return;
            }
            
            if (![[HETAccounts shared]currentAccount].refreshToken) {
                NSError *err=[[NSError alloc]initWithDomain:NSStringFromClass([self class]) code:1000 userInfo:@{@"msg":@"当前账号的refreshToken为空"}];
                failure(nil,err);
                dispatch_semaphore_signal(_sema);
                return;
            }
            
            //NSLog(@"刷新token:%@,%@",[self refreshAcessTokenRequestUrl:account.refreshToken],account.accessToken);
            [self requestWithURLRequest:[self refreshAcessTokenRequestUrl:account.refreshToken] BlockWithSuccess:^(HETNetWorkRequestOperation *operation, id responseObject) {
                dispatch_semaphore_signal(_sema);
                NSDictionary *result = responseObject;
                NSInteger code= [[(NSDictionary *)result objectForKey:@"code"] integerValue];
                if (code!=0) {
                    NSLog(@"刷新token:%@",[(NSDictionary *)result objectForKey:@"msg"]);
                    NSError *error=[[NSError alloc]initWithDomain:NSStringFromClass([self class]) code:1000 userInfo:responseObject];
                    failure(operation,error);
                    return;
                    
                }
                
                /*
                 {
                 accessToken = 2124ae261f1e4cc490c2afdb059edea2;
                 accessTokenExpires = 28800;
                 refreshToken = dd134ba07a74463caf2ce1b38cbff12d;
                 refreshTokenExpires = 2592000;
                 };
                 */
                NSDictionary *dict = [(NSDictionary *)result objectForKey:@"data"];
                NSString *accessToken   =  [dict objectForKey:@"accessToken"];
                NSString *openId        =  [dict objectForKey:@"openId"];
                NSString * expiresIn    =  [dict objectForKey:@"expiresIn"];
                NSString *refreshToken  =  [dict objectForKey:@"refreshToken"];
                NSString *refreshTokenExpires =[dict objectForKey:@"refreshTokenExpires"];
                
                if (accessToken.length > 0 && openId.length > 0) {
                    HETAccount *account = [HETAccount new];
                    account.accessToken = accessToken;
                    account.openId = openId;
                    account.refreshToken = refreshToken;
                    account.expirationDate = [NSDate dateWithTimeIntervalSinceNow:[expiresIn integerValue]];
                    account.refreshTokenDate=[NSDate dateWithTimeIntervalSinceNow:[refreshTokenExpires integerValue]];
                    
                    [[HETAccounts shared] addAccount:account];
                    [[HETNetWorkRequest shared] setAccessToken:accessToken];
                    
                    
                    
                    NSURLRequest *request = [HETURLRequestHelper postMultipartFormDataRequestWithUrl:requestUrl params:param];
                    [self requestWithURLRequest:request BlockWithSuccess:success failure:failure];
                }
                else
                {
                    NSLog(@"刷新Token请求得到的数据为:%@!",responseObject);
                }
                
                
                
            } failure:^(HETNetWorkRequestOperation *operation, NSError *error) {
                NSLog(@"error:%@",error);
                dispatch_semaphore_signal(_sema);
                failure(operation,error);
                
            }];
            
            
        });
    };

    
    
    
    
    // accessToken尚未失效，直接访问
    if ([refreshTime compare:account.expirationDate]!=NSOrderedDescending) {
        
            NSURLRequest *request = [HETURLRequestHelper postMultipartFormDataRequestWithUrl:requestUrl params:param];
            [self requestWithURLRequest:request BlockWithSuccess:^(HETNetWorkRequestOperation *operation, id responseObject) {
                
                if([responseObject isKindOfClass:[NSDictionary class]])
                {
                    NSString *code=[responseObject objectForKey:@"code"];
                    if(code.intValue==0)
                    {
                        success(operation,responseObject);
                    }
                    else
                    {
                        if(code.intValue==100010101)//token过期
                        {
                            requestAccessToken();
                            
                            
                            
                        }
                        else
                        {
                            //NSLog(@"%@",[responseObject objectForKey:@"msg"]);
                            failure(operation,[NSError errorWithDomain:NSStringFromClass([self class]) code:1003 userInfo:responseObject]);
                        }
                        
                        
                        
                    }
                    
                }

                
            } failure:^(HETNetWorkRequestOperation *operation, NSError *error) {
                  failure(operation,error);
            }];
        
    }
    
    // accessToken失效，refreshToken未失效，刷新后再访问
    else /*if ((account.refreshToken!= nil)
          && ([refreshTime compare:account.expirationDate]==NSOrderedDescending)
          && ([refreshTime compare:account.refreshTokenDate]!=NSOrderedDescending))*/
    {
        // 刷新token
        /*[self requestWithURLRequest:[self refreshAcessTokenRequestUrl:account.refreshToken] BlockWithSuccess:^(HETNetWorkRequestOperation *operation, id responseObject) {
            NSDictionary *result = responseObject;
            NSInteger code= [[(NSDictionary *)result objectForKey:@"code"] integerValue];
            if (code!=0) {
                
            }
            
            NSDictionary *dict = [(NSDictionary *)result objectForKey:@"data"];
            NSString *accessToken   =  [dict objectForKey:@"accessToken"];
            NSString *openId        =  [dict objectForKey:@"openId"];
            NSString * expiresIn    =  [dict objectForKey:@"expiresIn"];
            NSString *refreshToken  =  [dict objectForKey:@"refreshToken"];
            NSString *refreshTokenExpires =[dict objectForKey:@"refreshTokenExpires"];
            
            if (accessToken.length > 0 && openId.length > 0) {
                HETAccount *account = [HETAccount new];
                account.accessToken = accessToken;
                account.openId = openId;
                account.refreshToken = refreshToken;
                account.expirationDate = [NSDate dateWithTimeIntervalSinceNow:[expiresIn integerValue]];
                account.refreshTokenDate=[NSDate dateWithTimeIntervalSinceNow:[refreshTokenExpires integerValue]];
                
                [[HETAccounts shared] addAccount:account];
                [[HETNetWorkRequest shared] setAccessToken:accessToken];
                NSURLRequest *request = [HETURLRequestHelper postMultipartFormDataRequestWithUrl:requestUrl params:param];
                [self requestWithURLRequest:request BlockWithSuccess:success failure:failure];
                
            }
            
            
        } failure:^(HETNetWorkRequestOperation *operation, NSError *error) {
            
            failure(operation,error);
            
        }];*/
        
        // 刷新token
        /**
         *  异步去请求刷新token
         *
         */
        
        
        requestAccessToken();

    }

}





//32位MD5加密方式
- (NSString *)getMd5_32Bit_String:(NSString *)srcString{
    const char *cStr = [srcString UTF8String];
    unsigned char digest[CC_MD5_DIGEST_LENGTH];
    CC_MD5( cStr, (CC_LONG)strlen(cStr), digest );
    NSMutableString *result = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
    for(int i = 0; i < CC_MD5_DIGEST_LENGTH; i++)
        [result appendFormat:@"%02x", digest[i]];
    
    return result;
}

- (NSDictionary *)generateSignWithHTTPMethod: (HETRequestMethod)method  withRequestUrl:(NSString *)requestUrl processParams:(NSDictionary *)params needSign:(BOOL)needSign{
    
    NSString *signSeed = @"";
    
    // 请求URL
    NSString *url = requestUrl;
    
    // 请求参数
    NSMutableDictionary *param = params ? [NSMutableDictionary dictionaryWithDictionary:params] : [NSMutableDictionary dictionary];
    if (![param objectForKey:@"accessToken"] && self.accessToken) {
        [param setObject:self.accessToken forKey:@"accessToken"];
    }
    if(needSign)
    {
      switch (method) {
         case HETRequestMethodGet:
         {
            signSeed = [signSeed stringByAppendingString: @"GET"];
            break;
         }
         case HETRequestMethodPost:
         {
            signSeed = [signSeed stringByAppendingString: @"POST"];
            break;
         }
         case HETRequestMethodHead:
         {
            break;
         }
         case HETRequestMethodPut:
         {
            break;
         }
         case HETRequestMethodDelete:
         {
            break;
         }
         case HETRequestMethodPatch:
         {
            break;
         }
         default:
            break;
    }
    
    
    signSeed = [signSeed stringByAppendingString: url];
    signSeed = [signSeed stringByAppendingString: [self dictionaryToString: param]];
    
    // 再加上appSecret
    if (self.appSecret != nil) {
        signSeed = [signSeed stringByAppendingString: @"&"];
        signSeed = [signSeed stringByAppendingString: self.appSecret];
    }
    NSString *sign = [self getMd5_32Bit_String: signSeed];
    
     param[@"sign"] = sign;
    }
    return param;
}

- (NSString *)dictionaryToString: (NSDictionary *)param{
    
    NSString *str = @"";
    NSArray *keyArray = [[param allKeys] sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
        return (NSComparisonResult)[obj1 compare:obj2];
    }];
    
    NSUInteger count = [keyArray count];
    for (NSUInteger i=0; i<count; i++) {
        NSString *key = keyArray[i];
        id value = param[key];
        NSString *valueStr;
        if ([value isKindOfClass: [NSNumber class]]) {
            valueStr = [NSString stringWithFormat: @"%ld", (long)[value integerValue]];
        }else if ([value isKindOfClass: [NSString class]]){
            valueStr = value;
        }
        str = [str stringByAppendingString: key];
        str = [str stringByAppendingString: @"="];
        str = [str stringByAppendingString: valueStr];
        if (i < count-1) {
            str = [str stringByAppendingString: @"&"];
        }
    }
    
    return str;
}
- (NSURLRequest *)refreshAcessTokenRequestUrl:(NSString*)refreshToken
{
    NSDictionary *params = [NSDictionary dictionaryWithObjectsAndKeys:
                            self.appKey, @"appId",
                            refreshToken, @"refreshToken",
                            @"refreshToken", @"grantType",
                            nil];
    return  [HETURLRequestHelper postRequestWithUrl:self.refreshAccessTokenURL  params:params];
    
}
@end
