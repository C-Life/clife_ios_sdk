//
//  HFWIFINewProtocol.m
//  NewBindDeviceProject
//
//  Created by mr.cao on 15/6/29.
//  Copyright (c) 2015年 mr.cao. All rights reserved.
//
/**
 * v42版本协议格式
 * -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 * | 0xF2 | Protocol Version | Protocol Type | Command Type | Mac Addr | Device Type | Frame Control & WIFI status | Frame SN | Reserved | Length | Frame Body | Frame Body FCS | FCS  |
 * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 * | 1byte|       1byte      |     1byte     |      2byte   |   6byte  |     8byte   |               2byte         |   4byte  |   8byte  |  2byte |   Nbyte    |       2byte    | 2byte|
 * -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 <f2 42 02 0001  accf2356becc    00000000 040b0100   40 00000000 00000000 00000000 00000000 005bbc>
 
  f2 42 02 0001  accf2356becc    00000199 0b040100   40 00000000 00000000 00000000 00000000 00bc5b
 <f2 42 02 4010  000000000000    00000000 00040000 （19）
   0000 00000000（25）  0000000000000000（33）  0027（35）     771d095823（40） 29383964 30333636 62626566 36366638 37343035 39313233 66316164 31376330 336e（74）   c2d6（76）  9451（78）>
 <f2 42 02 4010  000000000000    00000199 0b04000000 00 000000 00000000 00000000 00002777 1d095823 29383964 30333636 62626566 36366638 37343035 39313233 66316164 31376330 336ed2ca 2e51>
 * <p/>
 * 0xF2: 帧开始标志;
 * Protocol Version:协议版本，详情见版本表(注 1);
 * Protocol Type:协议类型 升级协议为0x10,业务数据 0x00,绑定协议为 0x02;
 * Command Type:相关操作命令字,高字节为数据方向; Bit7~Bit7  数据源：10-服务器 01-手机 00-终端
 * Mac Addr:客户端 WIFI 模组的 MAC 地址 ACCF233BA86A;
 * Device Type:包括设备品牌【4】设备的类型，高字节大分类【1】，低字节小分类【1】，数据协议版本【1】，保留【1】;
 * Frame Control & WIFI status:高字节数据状态，低字 WIFI 信号强度;(注 2)
 * Frame SN:数据帧序号;
 * Reserved:保留位;
 * Length:Frame body 的长度，汉枫模块不超过200 字节;
 * Frame Body:帧数据段字节数，合法值范围：0～1024(注)，汉枫模块不超过 200 字节;
 * Frame Body FCS:Frame Body 部分未加密前的 FCS,不加密的数据填 0x0000;
 * FCS:帧数据段内容 CRC16 校验值(CRC-16/X25 X16+X12+X5+1),包含所有帧数据除外不包含0xF2;
 * <p/>
 * <p/>
 * 注1：协议版本号这里包括主协议版本和子协议版本。详情如下表 4-2。
 * 表 4-2 协议版本说明
 * --------------------------------------------------------------
 * |      类型        |      数据值       |         类型描述        |
 * |--------------------------------------------------------------|
 * |                 |       00         |       老版本协议         |
 * |                 |--------------------------------------------|
 * | 主版本号(b7b6)   |       11         |       新版本协议          |
 * |                 |--------------------------------------------|
 * |                 |     10~11        |          预留            |
 * |--------------------------------------------------------------|
 * |    子协议版本号   |     000~111      |      根据具体子协议而定    |
 * | （b5b4b3.b2b1b0) |                  |                        |
 * --------------------------------------------------------------
 * <p/>
 * 注2：数据状态（如下表 4-3）和WiFi状态(如下表 4-4)；
 * <p/>
 * 表 4-3 数据状态
 * ------------------------------------------------------------------------------------------------------------------------------------------------
 * |         数据及数据状态          |      Bit7    |    Bit6    |    Bit5      |                 Bit4                               |   Bit3~Bit0    |
 * |------------------------------------------------------------------------------------------------------------------------------------------------|
 * |   Bit4~Bit7标示当前数据帧的性质 |   1:发送数据 |  1:请求数据 |   1:应答数据 |   0：数据需要应答；1：数据不用应答【只结合发送数据使用】   |    保留        |
 * ------------------------------------------------------------------------------------------------------------------------------------------------
 * <p/>
 * 表 4-4 WIFI状态
 * ------------------------------------------------------------------------------------------------------------------------
 * |         WIFI状态      |      Bit7     |      Bit6     |       Bit5     |        Bit4      |          Bit3~Bit0          |
 * ------------------------------------------------------------------------------------------------------------------------
 * |   Bit0~Bit3信号强度   |     保留      |      保留     |       保留     |       保留       |  WIFI信号强度0~10对应0%~100%  |
 * ------------------------------------------------------------------------------------------------------------------------
 */
#import "HETWIFINewProtocol.h"
//#import "HETUserDefaultsPreference.h"
#import <sys/socket.h>
#import <sys/sysctl.h>
#import <net/if.h>
#import <net/if_dl.h>
#import <ifaddrs.h>
//#import <NSString+SAMAdditions.h>
#import <arpa/inet.h>

@implementation HETWIFINewProtocol
+(HETWIFICommonReform*)transformData:(NSData *)data
{
    HETWIFICommonReform *obj = [[HETWIFICommonReform alloc] init];
    
    const char* bytes = [data bytes];
    int length = (int)data.length;
    char start1 = *bytes;
    unsigned int cmd = 0;
    unsigned short length1 =*(unsigned short *)(bytes + 33);
    UInt64 macaddr=0;
    NTOHS(length1);
    //报文头不对
    if (start1 != (char)0xf2) {
        return nil;
    }
    //长度不等
    if (length1+39 != length) {
        return nil;
    }
    unsigned short frameBodyCRC = [self crc16with:bytes+36 andlength:length-39];
    unsigned short frameBodycrc = NTOHS(*(unsigned short *)(bytes +length -4));
    //frameBody CRC校验失败
    if (frameBodycrc != frameBodyCRC) {
        return nil;
    }

    
    
    
    unsigned short temp1 = [self crc16with:bytes+1 andlength:length-3];
    unsigned short crc = NTOHS(*(unsigned short *)(bytes +length -2));
    //整个数据CRC校验失败
    if (crc != temp1) {
        return nil;
    }
    
    
    unsigned long long temp;
    memcpy((char *)&temp, bytes+5, 8);
    macaddr = (((unsigned long long )ntohl((unsigned int)((temp << 32) >> 32))) << 32) | (unsigned int)ntohl((int)(temp >> 32));
    macaddr = macaddr>>16;
    
    NSString *mac = [[NSString stringWithFormat:@"%llx",macaddr] uppercaseString];
    char Pro_version = *(bytes+1);
    char Pro_type = *(bytes +2);
    cmd = (*(bytes +3))*256 + *(bytes +4);
    unsigned short Dev_type =  NTOHS(*(unsigned short *)(bytes + 11+4));
    NSData *content = [NSData dataWithBytes:bytes+16 length:length1];
    
    unsigned long device_brand=ntohl(*(unsigned long *)(bytes + 11));
    unsigned short wifistatus  =NTOHS(*(unsigned short *)(bytes + 19));
    
    obj.startflag=start1;
    obj.protocol_version=Pro_version;
    obj.protocol_type=Pro_type;
    obj.device_type=((Dev_type&0xff00)>>8);
    obj.device_subtype=(Dev_type&0x00ff);
    obj.device_mac=mac;
    obj.device_cmdtype=cmd;
    obj.body=content;
    obj.body_length=length1;
    obj.device_brand=device_brand;
    obj.device_wifiStatus=wifistatus;
    obj.packetNum=(bytes[38]<<8) + bytes[39];
    obj.direction=bytes[36]&0xf0;
    obj.replay=bytes[36]&0x0f;
    return obj;
    
    
}
+(NSData *)fetchBindPacketWithObj:(HETWIFICommonReform *)obj{
    unsigned char ipArray[1];
    for(int i = 0;i<1;i++){
        //NSDictionary *dic = deviceInfo;
        NSString *iptr=obj.device_ip;//[dic objectForKey:@"ip"];
        unsigned char lastIpNum = [[[iptr componentsSeparatedByString:@"."] lastObject] integerValue];
        ipArray[i] = lastIpNum;
    }
    
    
    NSDictionary *serverDic = [[NSUserDefaults standardUserDefaults] objectForKey:@"HETServerConfig"];
    // NSString *md5 = [[NSUserDefaults standardUserDefaults] objectForKey:@"accountAndPassMd5Str"];
    if ([HETUserInfo userInfo].userId == nil) {
        return nil ;
    }

    NSString *md5 = [HETUserInfo userInfo].userId;
    unsigned int ip = inet_addr([[serverDic objectForKey:@"serverIp"] UTF8String]);
    unsigned short port = [[serverDic objectForKey:@"serverPort"] shortValue];
    
    char content[38+1];
    memset(content, 0, 38+1);
    *(unsigned int *)(content) = ip;
    *(unsigned short *)(content +4) = htons(port);
    memcpy(content + 6, [md5 UTF8String], 32);
    memcpy(content + 38, ipArray, 1);

    obj.body=[NSData dataWithBytes:content length:38+1];
    obj.device_cmdtype=0x4010;
    obj.protocol_type=0x02;
    //obj.device_mac=@"000000000000";
    NSData *contentData = obj.body;
    char Pro_ver =obj.protocol_version;
    char Pro_type =obj.protocol_type ;
    unsigned short temp1 = obj.device_cmdtype;
    unsigned short cmd = HTONS(temp1);
    unsigned short temp2 =  (obj.device_subtype&0x00ff)|((obj.device_type<<8)&0xff00);
    unsigned short Dev_subtype = HTONS(temp2);
    
    //unsigned short temp3 =  obj.device_type;
    //unsigned short Dev_type = HTONS(temp3);
    unsigned long temp4 = obj.device_brand;
    unsigned long  device_brand=htonl(temp4);
    NSString *macaddrstr = obj.device_mac;
    
    unsigned long long temp;
    NSScanner *scanner = [NSScanner scannerWithString:macaddrstr];
    (void) [scanner scanHexLongLong:&temp];
    unsigned long long macaddr;
    macaddr = (((unsigned long long )htonl((unsigned int)((temp << 32) >> 32))) << 32) | (unsigned int)htonl((int)(temp >> 32));
    macaddr = macaddr>>16;
    
    unsigned short temp3 = [contentData length];
    char retdata[39+temp3];
    memset(retdata,0, 39+temp3);
    int length = 39+temp3;
    unsigned short contentLength = temp3;
    HTONS(contentLength);
    retdata[0] = 0xf2;
    retdata[1] = Pro_ver;
    retdata[2] = Pro_type;
    memcpy(retdata+3, (char *)(&cmd), 2);
    memcpy(retdata+5, (char *)(& macaddr), 6);
    //
    memcpy(retdata+11, (char *)(& device_brand), 4);
    
    memcpy(retdata+15, (char *)(& Dev_subtype), 2);
    
    memcpy(retdata+33, (char *)(&contentLength), 2);
    memcpy(retdata+35, [contentData bytes], [contentData length]);
    
    unsigned short frameBodyCRC = [self crc16with:retdata+35 andlength:length-39];
    unsigned short frameBodycrc = HTONS(frameBodyCRC);
    
     memcpy(retdata+length-4, (char *)(& frameBodycrc), 2);

    
    unsigned short frameCRC = [self crc16with:retdata+1 andlength:length-3];
    unsigned short framecrc = HTONS(frameCRC);
    memcpy(retdata+length-2, (char *)(& framecrc), 2);
    
    return [NSData dataWithBytes:retdata length:39+temp3];
}
+(NSData *)fetchLittleLoopPacketWithObj:(HETWIFICommonReform *)obj
{
   
    NSData *contentData =obj.body;// [dic objectForKey:@"data"];
    char Pro_ver =obj.protocol_version;// [[dic objectForKey:@"proversion"] charValue];
    char Pro_type =obj.protocol_type;// [[dic objectForKey:@"protype"] charValue];
    unsigned short temp1 =obj.device_cmdtype;// [[dic objectForKey:@"cmd"] shortValue];
    unsigned short cmd = HTONS(temp1);
    unsigned short temp2 =  (obj.device_subtype&0x00ff)|((obj.device_type<<8)&0xff00);
    unsigned short Dev_subtype = HTONS(temp2);
    unsigned long temp4 = obj.device_brand;
    unsigned long  device_brand=htonl(temp4);
    NSString *macaddrstr =obj.device_mac;// [dic objectForKey:@"mac"];
    
    unsigned long long temp;
    NSScanner *scanner = [NSScanner scannerWithString:macaddrstr];
    (void) [scanner scanHexLongLong:&temp];
    unsigned long long macaddr;
    macaddr = (((unsigned long long )htonl((unsigned int)((temp << 32) >> 32))) << 32) | (unsigned int)htonl((int)(temp >> 32));
    macaddr = macaddr>>16;
    
    unsigned short temp3 = [contentData length];
    char retdata[39+temp3];
    memset(retdata,0, 39+temp3);
    int length = 39+temp3;
    unsigned short contentLength = temp3;
    retdata[0] = 0xf2;
    retdata[1] = Pro_ver;
    retdata[2] = Pro_type;
    memcpy(retdata+3, (char *)(&cmd), 2);
    memcpy(retdata+5, (char *)(& macaddr), 6);
    //
    memcpy(retdata+11, (char *)(& device_brand), 4);
    
    memcpy(retdata+15, (char *)(& Dev_subtype), 2);
    
    memcpy(retdata+33, (char *)(&contentLength), 2);
    memcpy(retdata+35, [contentData bytes], [contentData length]);
    
    unsigned short frameBodyCRC = [self crc16with:retdata+35 andlength:length-39];
    unsigned short frameBodycrc = HTONS(frameBodyCRC);
    
    memcpy(retdata+length-4, (char *)(& frameBodycrc), 2);
    
    
    unsigned short frameCRC = [self crc16with:retdata+1 andlength:length-3];
    unsigned short framecrc = HTONS(frameCRC);
    memcpy(retdata+length-2, (char *)(& framecrc), 2);
    
    return [NSData dataWithBytes:retdata length:39+temp3];

}

//CRC校验
+(unsigned short)crc16with:(const char *)data andlength:(int) length
{
    char j;
    int i;
    unsigned short retCrc16;
    retCrc16 = 0xffff;
    for(i=0;i<length;i++)
    {
        retCrc16 ^=((*data++)&0x000000ff);
        for(j = 0;j<8;j++){
            if(retCrc16&0x01)
            {
                retCrc16=(retCrc16>>1)^0x8408;
            }
            else{
                retCrc16>>=0x01;
            }
        }
    }
    return ~retCrc16;
}


@end
