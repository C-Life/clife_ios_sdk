
//
//  MattressBLEManagerApi.m
//  CLBlueToothTool
//
//  Created by Sandy wu on 15/6/8.
//  Copyright (c) 2015年 het. All rights reserved.
//

#import "HETBLEManagerApi.h"
#import "CSleepBlueToothDefine.h"
#import "HETBLEProtocol.h"



typedef enum {
    DeviceAdd         = 0,// 默认添加设备
    DeviceFridge      = 1,// 1: 冰箱
    DeviceWash        = 2,// 2: 洗衣机
    DeviceCondition   = 3,// 3: 空调
    DeviceNuanFeng    = 4,// 4: 暖风机
    DeviceHumidifier  = 5,// 5: 加湿器
    DeviceMattress    = 6,// 6: 喜临门睡眠监测器
    DeviceAirClean    = 7,// 7: 空气清新机
    DeviceHotWater    = 8,// 8: 热水器
    DeviceSnore       = 9,// 9: 鼾声检测
    DeviceTurn        = 10,// 10: 翻身检测
    DeviceAroma       = 11,// 11: 香薰机
    DeviceStir        = 12,// 12: 搅拌机
    DeviceTempControl = 13,// 13: 温控器
    DeviceLight       = 14,// 14: LED 电灯
    DeviceElecOven    = 15,// 15: 电烤箱
    DeviceAirBox      = 16,// 16: 空气盒子
    DeviceAirFan      = 17,// 17: 吊顶风扇
    DeviceSleepBox    = 18,// 18: 睡眠盒子
    DeviceSlowCooker  = 19,// 19: 慢炖锅
    DeviceWaterCup    = 20,// 20: 水杯
    DeviceCurtain     = 21,// 21: 电动窗帘
    DeviceOutlet      = 22,// 22: 插座
    DeviceBleToWifi   = 23,// 23: 蓝牙转WIFI
    DeviceCigarette   = 24,// 24: 电子烟
    
    DeviceSleepButton = 26,// 26: 睡眠记录器
    DeviceMusicBox    = 27,// 27: 音箱
    DeviceBleWifiBox  = 28,
    DeviceCough       = 29,// 25: 咳嗽检测
    DeviceSleepScene  = 30,
    DeviceSkinTest    = 31,//31:测肤仪
    DeviceCleanFace   = 34,//34:洁面仪
    DeviceLlskincleaner = 35, //35. 提拉
    DevicePortablesprayer = 36,//36. 便捷式喷雾仪
    DeviceImportExport = 37, //彩光导入导出仪)
    DeviceHotelTray = 40,    //酒店托盘
    
    DeviceSnorePillow = 42,  //止鼾枕头
    DeviceSleepBoxAirCondition = 43,  //红外空调
    
} DeviceType;



@interface HETBLEManagerApi()
{
    HETBLEProtocol* sendRealTimeData;

}

@property (nonatomic,copy  ) NSString          * uniqueID;
@property (nonatomic,strong) dispatch_source_t realDatatimer;

@property (nonatomic,assign) NSInteger         deviceTypeID;//设备大类类型
@property (nonatomic,assign) NSInteger         deviceSubTypeID;//设备子类类型

@end


@implementation HETBLEManagerApi

-(void)dealloc{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [self stopFetchRealTimeData];
    [[CLBLEManager sharedInstance] disconntectPeripheral:self.currentPeripheral withResultBlock:^(NSError *error) {
    }];
    if( self.currentPeripheral)
    {
        self.currentPeripheral=nil;
    }

   
}
- (instancetype)init
{
    self = [super init];
    if(self)
    {
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleDisconnectNotification:) name:kLGPeripheralDidDisconnect object:nil];
    }
    return self;
}

- (void) handleDisconnectNotification:(NSNotification*)notification
{
    self.currentPeripheral=nil;
    
}


-(void)stopFetchRealTimeData
{
        if (self.realDatatimer){
                   dispatch_async(dispatch_get_main_queue(), ^{
                dispatch_source_cancel(self.realDatatimer);
            });
        }
    

    //self.state=CLBLEStateIdle;
}
-(void)suspendFetchRealTimeData
{
//    if (self.realDatatimer)
//        dispatch_suspend(self.realDatatimer);
}
-(void)resumeFetchRealTimeData
{
//    if (self.realDatatimer)
//        dispatch_resume(self.realDatatimer);
}

-(void)fetchRealTimeDataWithInterVal:(NSTimeInterval)interval
                           WithTimes:(NSTimeInterval)times
                        SuccessBlock:(void(^)(NSData* data))success
                           FailBlock:(void(^)(NSError* error))fail
{
    dispatch_async(dispatch_get_main_queue(), ^{
        if (self.realDatatimer) {
            return;
        }
        __block NSUInteger  tick=0;
        dispatch_queue_t queue = dispatch_get_main_queue();
        self.realDatatimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);
        dispatch_source_set_timer(self.realDatatimer,dispatch_walltime(NULL, 0),(interval?:3)*NSEC_PER_SEC, 0);
        dispatch_source_set_event_handler(self.realDatatimer, ^{
            if (self.realDatatimer==NULL) {
                return ;
            }
            if (tick < (times?:NSIntegerMax)){
                
                if ( self.state != CLBLEStateIdle) {
                    //NSError* error=[NSError errorWithDomain:@"MattressBLEManagerApi" code:-1 userInfo:@{@"userInfo":@"蓝牙繁忙"}];
                     NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEBusyErrorCode userInfo:@{@"message":kBLEBusyErrorCodeErrorMessage}];
                    fail(error);
                    return ;
                }
               // NSLog(@"fetchRealTimeDataWithInterVal00");
                __weak HETBLEManagerApi* weakSelf=self;
                if (self.connectedPeripheral.cbPeripheral.state==CBPeripheralStateConnected) {
                    sendRealTimeData =[HETBLEProtocol getRequestRealTimePacketData:self.uniqueID];
                    [self sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                                    Success:^(NSData *data) {
                                                        /*获取成功要分三种情况:
                                                         1.如果是正式版本，只判断上床还是下床，分别调用服务器接口，把
                                                         这两种状态给服务器，做联动.
                                                         2.如果是展厅版本，除了要上传上床和下床指令，还要把每一笔实时数据
                                                         给到服务器。
                                                         3.上床和下床用KVO来做：初始化的时候，判断呼吸、心跳和翻身，如果
                                                         任意一个有值，就判断为上床；不是初始化的情况，监控变化，只要有变化，
                                                         也是判断呼吸、心跳和翻身的值来判断是上床还是下床。
                                                         */
                                                        success(data);
                                                        NSLog(@"data is %@",data);
                                                    } fail:^(NSError *error) {
                                                        NSLog(@"error is %@",error);
                                                        fail(error);
                                                    }];
                    
                }
                else{
                    //NSLog(@"fetchRealTimeDataWithInterVal001");
                    self.currentPeripheral=nil;
                    
                    [[CLBLEManager sharedInstance] conntectPeripheralWithBLEDataSource:self
                                                                       withResultBlock:^(LGPeripheral *peripheral, NSError *error) {
                                                                           //NSLog(@"fetchRealTimeDataWithInterVal01");
                                                                           if (error) {
                                                                               fail(error);
                                                                               
                                                                               NSLog(@"连接失败error%@",error);
                                                                               
                                                                           }
                                                                           else{
                                                                               weakSelf.currentPeripheral=peripheral;
                                                                               sendRealTimeData =[HETBLEProtocol getRequestRealTimePacketData:self.uniqueID];
                                                                               [self sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                                                                                               Success:^(NSData *data) {
                                                                                                                   /*获取成功要分三种情况:
                                                                                                                    1.如果是正式版本，只判断上床还是下床，分别调用服务器接口，把
                                                                                                                    这两种状态给服务器，做联动.
                                                                                                                    2.如果是展厅版本，除了要上传上床和下床指令，还要把每一笔实时数据
                                                                                                                    给到服务器。
                                                                                                                    3.上床和下床用KVO来做：初始化的时候，判断呼吸、心跳和翻身，如果
                                                                                                                    任意一个有值，就判断为上床；不是初始化的情况，监控变化，只要有变化，
                                                                                                                    也是判断呼吸、心跳和翻身的值来判断是上床还是下床。
                                                                                                                    */
                                                                                                                   success(data);
                                                                                                                   NSLog(@"data is %@",data);
                                                                                                               } fail:^(NSError *error) {
                                                                                                                   NSLog(@"error is %@",error);
                                                                                                                   fail(error);
                                                                                                               }];
                                                                           }
                                                                       }];
                    
                }
        }else{
            dispatch_source_cancel(self.realDatatimer);
        }
         tick ++;
    });
    dispatch_source_set_cancel_handler(self.realDatatimer, ^{
        dispatch_source_set_event_handler_f(self.realDatatimer,NULL);
#if !OS_OBJECT_USE_OBJC
            dispatch_release(self.realDatatimer);
#endif
        self.realDatatimer = NULL;
        });
        dispatch_resume(self.realDatatimer);
    });
    
}

-(void)fetchRealTimeDataSuccessBlock:(void(^)(NSData* data))success
                           FailBlock:(void(^)(NSError* error))fail{
    if (self.connectedPeripheral.cbPeripheral.state==CBPeripheralStateConnected){
        //NSLog(@"CBPeripheralStateConnected");
         sendRealTimeData=[HETBLEProtocol getRequestRealTimePacketData:self.uniqueID];
        [self sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                        Success:^(NSData *data) {
                                            NSLog(@"data is %@",data);
                                            success(data);
                                        } fail:^(NSError *error) {
                                            NSLog(@"error is %@",error);
                                            fail(error);
                                        }];

    }else{
        self.currentPeripheral=nil;
         __weak HETBLEManagerApi* weakSelf=self;
        [[CLBLEManager sharedInstance] conntectPeripheralWithBLEDataSource:self
                                                           withResultBlock:^(LGPeripheral *peripheral, NSError *error) {
           if (error) {
               fail(error);
           }
           else{
               weakSelf.currentPeripheral=peripheral;
               sendRealTimeData=[HETBLEProtocol getRequestRealTimePacketData:self.uniqueID];
               [self sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                               Success:^(NSData *data) {
                                                   NSLog(@"data is %@",data);
                                                   success(data);
                                               } fail:^(NSError *error) {
                                                   NSLog(@"error is %@",error);
                                                   fail(error);
                                               }];
           }

        }];

    }

}




-(void)fetchHistoryDataWithSuccessBlock:(void(^)(NSData* data))success
                              FailBlock:(void(^)(NSError* error))fail{
    
    //NSLog(@"fetchHistoryDataWithSuccessBlock0");
    //NSLog(@"CLBLEStateIdle == %d",CLBLEStateIdle);
   // NSLog(@"self.state == %d",self.state);
    
    //不相等说明蓝牙繁忙
    if ( self.state != CLBLEStateIdle) {
        NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEBusyErrorCode userInfo:@{@"message":kBLEBusyErrorCodeErrorMessage}];;
        fail(error);
        return ;
    }
     __weak HETBLEManagerApi* weakSelf=self;
    if (self.connectedPeripheral.cbPeripheral.state==CBPeripheralStateConnected) {
        sendRealTimeData =[HETBLEProtocol getRequestStatisticalPacketData:self.uniqueID];
        [self sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                        Success:^(NSData *data) {
                                            /*历史数据比较简单，获取历史数据，上传到服务器，然后通知设备，清除数据。
                                             然后告诉外面结果就说成功了，
                                             业务接口自己去服务器拉取数据，整个上传数据流程完毕。
                                             */
                                            
                                            success(data);
                                            
                                        } fail:^(NSError *error) {
                                            NSLog(@"error is %@",error);
                                            fail(error);
                                        }];
    }
    else{
        //NSLog(@"fetchHistoryDataWithSuccessBlock11");
        self.currentPeripheral=nil;
        [[CLBLEManager sharedInstance] conntectPeripheralWithBLEDataSource:self
                                                           withResultBlock:^(LGPeripheral *peripheral, NSError *error) {
                                                               NSLog(@"fetchHistoryDataWithSuccessBlock1");
                       if (error) {
                           fail(error);
                       }
                       else{
                           weakSelf.currentPeripheral=peripheral;
                           sendRealTimeData =[HETBLEProtocol getRequestStatisticalPacketData:self.uniqueID];
                           [weakSelf sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                                           Success:^(NSData *data) {
                                                               /*历史数据比较简单，获取历史数据，上传到服务器，然后通知设备，清除数据。
                                                                然后告诉外面结果就说成功了，
                                                                业务接口自己去服务器拉取数据，整个上传数据流程完毕。
                                                                */
                                                               //success(data);
                                                               //NSLog(@"data is %@",data);
                                                               HETBLEReform *transFormData = [HETBLEProtocol transformData:data];
                                                               if (transFormData.body.length > 0) {
                                                                   
                                                                   success(transFormData.body);
                                                                   NSLog(@"data is %@",transFormData.body);
                                                               }
                                                               else
                                                               {
                                                                   success(nil);
                                                               }
                                                           } fail:^(NSError *error) {
                                                               NSLog(@"error is %@",error);
                                                               fail(error);
                                                           }];
                       }
        }];
    }

}

-(void)deleteHistoryDataWithSuccessBlock:(void(^)(NSData* data))success
                                   FailBlock:(void(^)(NSError* error))fail
{
    if ( self.state != CLBLEStateIdle) {
         NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEBusyErrorCode userInfo:@{@"message":kBLEBusyErrorCodeErrorMessage}];
        fail(error);
        return ;
    }
    __weak HETBLEManagerApi* weakSelf=self;
    if (self.connectedPeripheral.cbPeripheral.state==CBPeripheralStateConnected) {
        sendRealTimeData=[HETBLEProtocol getDeleteStatisticalPacketData:self.uniqueID];
        [self sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                        Success:^(NSData *data) {
                                            //NSLog(@"data is %@",data);
                                            //success(data);
                                            HETBLEReform *transFormData = [HETBLEProtocol transformData:data];
                                            if (transFormData.body.length > 0) {
                                                
                                                success(transFormData.body);
                                                NSLog(@"data is %@",transFormData.body);
                                            }
                                            else
                                            {
                                                success(nil);
                                            }

                                        } fail:^(NSError *error) {
                                            NSLog(@"error is %@",error);
                                            fail(error);
                                        }];
    }
    else{
        self.currentPeripheral=nil;
        [[CLBLEManager sharedInstance] conntectPeripheralWithBLEDataSource:self
                                                           withResultBlock:^(LGPeripheral *peripheral, NSError *error) {
                               if (error) {
                                   fail(error);
                               }
                               else{
                                   weakSelf.currentPeripheral=peripheral;
                                   sendRealTimeData=[HETBLEProtocol getDeleteStatisticalPacketData:self.uniqueID];
                                   [weakSelf sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                                                   Success:^(NSData *data) {
                                                                       //NSLog(@"data is %@",data);
                                                                       //success(data);
                                                                       HETBLEReform *transFormData = [HETBLEProtocol transformData:data];
                                                                       if (transFormData.body.length > 0) {
                                                                           
                                                                           success(transFormData.body);
                                                                           NSLog(@"data is %@",transFormData.body);
                                                                       }
                                                                       else
                                                                       {
                                                                           success(nil);
                                                                       }

                                                                   } fail:^(NSError *error) {
                                                                       NSLog(@"error is %@",error);
                                                                       fail(error);
                                                                   }];
                               }

        }];
    }
}


-(void)fetchBLEHandShakeSuccessBlock:(void(^)(NSData* data))success
                           FailBlock:(void(^)(NSError* error))fail
{

    if ( self.state != CLBLEStateIdle) {
       // NSError* error=[NSError errorWithDomain:@"MattressBLEManagerApi" code:-1 userInfo:@{@"userInfo":@"蓝牙繁忙"}];
        NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEBusyErrorCode userInfo:@{@"message":kBLEBusyErrorCodeErrorMessage}];
        fail(error);
        return ;
    }
     __weak HETBLEManagerApi* weakSelf=self;
    if (self.connectedPeripheral.cbPeripheral.state==CBPeripheralStateConnected) {
        sendRealTimeData =[HETBLEProtocol getRequestConfirmUpgrade:self.uniqueID];
        [self sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                        Success:^(NSData *data) {
                                            success(data);
                                            NSLog(@"data is %@",data);
                                        } fail:^(NSError *error) {
                                            NSLog(@"error is %@",error);
                                            fail(error);
                                        }];
    }
    else{
        self.currentPeripheral=nil;
        [[CLBLEManager sharedInstance] conntectPeripheralWithBLEDataSource:self
                                                           withResultBlock:^(LGPeripheral *peripheral, NSError *error) {
                                                               if (error) {
                                                                   fail(error);
                                                               }
                                                               else{
                                                                   weakSelf.currentPeripheral=peripheral;
                                                                   sendRealTimeData =[HETBLEProtocol getRequestConfirmUpgrade:self.uniqueID];
                                                                   [weakSelf sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                                                                                       Success:^(NSData *data) {
                                                                                                           success(data);
                                                                                                           NSLog(@"data is %@",data);
                                                                                                       } fail:^(NSError *error) {
                                                                                                           NSLog(@"error is %@",error);
                                                                                                           fail(error);
                                                                                                       }];
                                                               }
                                                           }];
    }

}

-(void)fetchProtocolVersionSuccessBlock:(void(^)(NSData* data))success
                              FailBlock:(void(^)(NSError* error))fail
{


    if ( self.state != CLBLEStateIdle) {
        //NSError* error=[NSError errorWithDomain:@"MattressBLEManagerApi" code:-1 userInfo:@{@"userInfo":@"蓝牙繁忙"}];
         NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEBusyErrorCode userInfo:@{@"message":kBLEBusyErrorCodeErrorMessage}];
        fail(error);
        return ;
    }
     __weak HETBLEManagerApi* weakSelf=self;
    if (self.connectedPeripheral.cbPeripheral.state==CBPeripheralStateConnected) {
        sendRealTimeData =[HETBLEProtocol getRequestProtocolVersion:self.uniqueID];
        [self sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                        Success:^(NSData *data) {
                                            success(data);
                                            NSLog(@"data is %@",data);
                                        } fail:^(NSError *error) {
                                            NSLog(@"error is %@",error);
                                            fail(error);
                                        }];
    }
    else{
        self.currentPeripheral=nil;
        [[CLBLEManager sharedInstance] conntectPeripheralWithBLEDataSource:self
                                                           withResultBlock:^(LGPeripheral *peripheral, NSError *error) {
                                                               if (error) {
                                                                   fail(error);
                                                               }
                                                               else{
                                                                   weakSelf.currentPeripheral=peripheral;
                                                                   sendRealTimeData =[HETBLEProtocol getRequestProtocolVersion:self.uniqueID];
                                                                   [weakSelf sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                                                                                       Success:^(NSData *data) {
                                                                                                           success(data);
                                                                                                           NSLog(@"data is %@",data);
                                                                                                       } fail:^(NSError *error) {
                                                                                                           NSLog(@"error is %@",error);
                                                                                                           fail(error);
                                                                                                       }];
                                                               }
                                                           }];
    }


}



- (void)fetchData:(NSData *)contentData
       withComdNO:(short)comdNO
withDeviceResponsePacketData :(NSData*)deviceResponsePacketData
wihAppResponsePacketData:(NSData *)appResponsePacketData
 withSuccessBlock:(void(^)(NSData* data))success
        FailBlock:(void(^)(NSError* error))fail;
{
    if ( self.state != CLBLEStateIdle) {
        //NSError* error=[NSError errorWithDomain:@"MattressBLEManagerApi" code:-1 userInfo:@{@"userInfo":@"蓝牙繁忙"}];
        NSError* error=[NSError errorWithDomain:kCLBLEManagerErrorDomain code:kBLEBusyErrorCode userInfo:@{@"message":kBLEBusyErrorCodeErrorMessage}];
        fail(error);
        return ;
    }
    __weak HETBLEManagerApi* weakSelf=self;
    if (self.connectedPeripheral.cbPeripheral.state==CBPeripheralStateConnected) {
        sendRealTimeData =[HETBLEProtocol getRequestPacketData:self.uniqueID withContentData:contentData withComdNO:comdNO withDeviceResponsePacketData:deviceResponsePacketData wihAppResponsePacketData:appResponsePacketData];
        [self sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                        Success:^(NSData *data) {
                                            success(data);
                                            NSLog(@"data is %@",data);
                                        } fail:^(NSError *error) {
                                            NSLog(@"error is %@",error);
                                            fail(error);
                                        }];
    }
    else{
        self.currentPeripheral=nil;
        [[CLBLEManager sharedInstance] conntectPeripheralWithBLEDataSource:self
                                                           withResultBlock:^(LGPeripheral *peripheral, NSError *error) {
                                                               if (error) {
                                                                   fail(error);
                                                               }
                                                               else{
                                                                   weakSelf.currentPeripheral=peripheral;
                                                                         sendRealTimeData =[HETBLEProtocol getRequestPacketData:self.uniqueID withContentData:contentData withComdNO:comdNO withDeviceResponsePacketData:deviceResponsePacketData wihAppResponsePacketData:appResponsePacketData];
                                                                   [weakSelf sendBLEDataWithDataPacketProtocol:sendRealTimeData
                                                                                                       Success:^(NSData *data) {
                                                                                                           success(data);
                                                                                                           NSLog(@"data is %@",data);
                                                                                                       } fail:^(NSError *error) {
                                                                                                           NSLog(@"error is %@",error);
                                                                                                           fail(error);
                                                                                                       }];
                                                               }
                                                           }];
    }
    

}

//根据不同设备业务类型，将二进制数据根据协议转换为字典

-(NSDictionary *)deviceInfoDictionary:(NSData *)dData
{
   
    if(self.deviceTypeID==DeviceSleepButton)//睡眠扣子
    {
        
    }
    else if (self.deviceTypeID==DeviceMattress)//床垫
    {
        if (dData.length <= 0) {
            return nil;
        }
        int heartValue=1;
        int breathValue=1;
        int turnOverValue=1;
        int batteryValue=1;
        int snoreValue=1;
        unsigned char havePeople = 1;//是否有人（新协议）
        unsigned char fault = 1;//故障代码（新协议）
        
        HETBLEReform * mattressReform = [HETBLEProtocol transformData:dData];
        if (!mattressReform) {
            return nil;
        }
        
        
        
        //协议版本判断
        if (mattressReform.protocol_version == 0x01)//新协议
        {
            [mattressReform.body getBytes:&heartValue range:NSMakeRange(0, 1)];
            [mattressReform.body getBytes:&breathValue range:NSMakeRange(1, 1)];
            [mattressReform.body getBytes:&havePeople range:NSMakeRange(2, 1)];
            [mattressReform.body getBytes:&turnOverValue range:NSMakeRange(3, 1)];
            if(mattressReform.body.length>5){
                [mattressReform.body getBytes:&batteryValue range:NSMakeRange(4, 1)];
            }
            [mattressReform.body getBytes:&fault range:NSMakeRange(5, 1)];
            
            
            //将第三个字节再进行解析（第三个字节包含两个信息Bit0: 呼吸暂停  Bit1: 有人(1)/无人(0)）
            if(havePeople&0x02)//有人
            {
                havePeople = 1;
            }
            else//无人
            {
                havePeople = 0;
            }
            
            
            NSLog(@"heartValue=%d,  breathValue=%d,  havePeople=%d,  turnOverValue=%d,  batteryValue=%d,  fault=%d",heartValue,breathValue,havePeople,turnOverValue,batteryValue,fault);
            
            
            
            //将数据保存到数据库
            NSDictionary * record = @{
                                      @"heartRate" : @(heartValue),
                                      @"breathRate" : @(breathValue),
                                      @"turnOverTimes" : @(turnOverValue),
                                      @"snoreTimes" : @(snoreValue),
                                      @"batteryValue" : @(batteryValue)
                                      };
            
          
            
            
            //上传实时数据到服务器
           // [self sendRealTimeToServerHeartRate:realTimeModel.heartValue andBreathRate:realTimeModel.breathValue andTurnOverTimes:realTimeModel.turnOverValue andSnoreTimes:realTimeModel.snoreValue andHavePeople:realTimeModel.havePeople andProtocolVersion:1];
            
            return record;
            
        }
        else if (mattressReform.protocol_version == 0x00)//旧协议
        {
            [mattressReform.body getBytes:&heartValue range:NSMakeRange(0, 1)];
            [mattressReform.body getBytes:&breathValue range:NSMakeRange(1, 1)];
            [mattressReform.body getBytes:&snoreValue range:NSMakeRange(2, 1)];
            [mattressReform.body getBytes:&turnOverValue range:NSMakeRange(3, 1)];
            
            if(mattressReform.body.length>4){
                [mattressReform.body getBytes:&batteryValue range:NSMakeRange(4, 1)];
            }
            NSLog(@"heartValue=%d,  breathValue=%d,  turnOverValue=%d,  batteryValue=%d 带子协议版本 == %d",heartValue,breathValue,turnOverValue,batteryValue,mattressReform.protocol_version);
            
           
            
            /* 设备互联 助眠模式 begin */
            // 开始判断上床动作
           /* realTimeModel.userID= [NSString stringWithFormat:@"%@", [HETUserInfo userInfo].userId];
            //    realTimeModel.mac=uniqueID;
            realTimeModel.realTimeDate=[[NSDate date] LocalTimeISO8601String];
            realTimeModel.heartValue=heartValue;
            realTimeModel.breathValue=breathValue;
            realTimeModel.turnOverValue=turnOverValue;
            realTimeModel.snoreValue=snoreValue;
            
            mattressBusiness.userID= [HETUserInfo userInfo].userId;
            mattressBusiness.deviceID = self.mattressId;
            
            //处理联动功能
            [self calcRealTimeSleep:realTimeModel];*/
            //记录此次的实时数据
            NSDictionary * record = @{
                                      @"heartRate" : @(heartValue),
                                      @"breathRate" : @(breathValue),
                                      @"turnOverTimes" : @(turnOverValue),
                                      @"snoreTimes" : @(snoreValue),
                                      @"batteryValue" : @(batteryValue)
                                      };
            
            //NSString * refreshTime = [[realTimeModel.realTimeDate substringWithRange:NSMakeRange(11, 8)] stringByReplacingOccurrencesOfString:@":" withString:@""];
            //[matrressRecord addMattressRealTimeRecord:record andDeviceId:self.mattressId andRefreshTime:refreshTime];
            //上传实时数据到服务器
           // [self sendRealTimeToServerHeartRate:realTimeModel.heartValue andBreathRate:realTimeModel.breathValue andTurnOverTimes:realTimeModel.turnOverValue andSnoreTimes:realTimeModel.snoreValue];
            return record;
            
        }
        
        
        
        
    
        
 
    }
    
    return nil;
}





-(NSString *)uniqueID
{
    NSString* uniqueIDStr=@"000000";
    if (self.currentPeripheral.name.length>=14) {
        uniqueIDStr=[self.currentPeripheral.name substringWithRange:NSMakeRange(4, 6)];
    }
    return uniqueIDStr;
}



-(NSInteger)deviceTypeID
{
    NSString*  typeID=@"0";
   if (self.currentPeripheral.name.length>=14) {
       NSArray *array=[self.currentPeripheral.name componentsSeparatedByString:@"-"];
       
       typeID=[array objectAtIndex:2];
   }
   
    return typeID.intValue;
}


-(NSInteger)deviceSubTypeID
{
    NSString*  typeID=@"0";
    if (self.currentPeripheral.name.length>=14) {
        NSArray *array=[self.currentPeripheral.name componentsSeparatedByString:@"-"];
        
        typeID=[array objectAtIndex:3];
    }
    
    return typeID.intValue;
 
}





#pragma mark - CLBLEDataSource
-(NSString*)broadName{
    return self.currentBroadName;
}

-(NSArray*)scanServiceArray{
    return @[[CBUUID UUIDWithString:CSLEEP_SERVICE_UUID]];
}

-(NSString*)readSeriveID{
    return CSLEEP_SERVICE_UUID;
}

-(NSString*)readCharacteristicID{
    return CSLEEP_READ_CHARACTER_UUID;
}

-(NSString*)writeSeriveID{
    return CSLEEP_SERVICE_UUID;
}

-(NSString*)writeCharacteristicID{
    return CSLEEP_WRITE_CHARACTER_UUID;
}

-(LGPeripheral*)connectedPeripheral{
    return self.currentPeripheral;
}

#pragma mark - getter and setter
-(BOOL)BLEIsPowerOn{
    //NSLog(@"BLEIsPowerOn:%d",[CLBLEManager sharedInstance].manager.state);
    if ([CLBLEManager sharedInstance].manager.state==CBCentralManagerStatePoweredOn||[CLBLEManager sharedInstance].manager.state==CBCentralManagerStateUnknown) {
        return YES;
    }
    else{
        return NO;
    }
}
@end
